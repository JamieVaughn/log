<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png"/><link rel="manifest" href="/favicons/site.webmanifest"/><link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicons/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta name="description" content="Thoughts on our awesome collective web platform."/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>The Good and Bad Parts of JS (according to Kyle Simpson) | Make Devs</title><meta property="og:image" content="/img/cover.jpg"/><meta name="next-head-count" content="16"/><link rel="preload" href="/log/_next/static/css/0dff263c2b12f909.css" as="style"/><link rel="stylesheet" href="/log/_next/static/css/0dff263c2b12f909.css" data-n-g=""/><link rel="preload" href="/log/_next/static/css/cf121497002c184d.css" as="style"/><link rel="stylesheet" href="/log/_next/static/css/cf121497002c184d.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/log/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/log/_next/static/chunks/webpack-c6d930e7ce3de825.js" defer=""></script><script src="/log/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/log/_next/static/chunks/main-b58ac34e0b98c3ee.js" defer=""></script><script src="/log/_next/static/chunks/pages/_app-90e414d931afb8eb.js" defer=""></script><script src="/log/_next/static/chunks/893-bb16ac16a245221e.js" defer=""></script><script src="/log/_next/static/chunks/349-6549a57f16834f01.js" defer=""></script><script src="/log/_next/static/chunks/pages/posts/%5Bslug%5D-8a2e5eb3b2262534.js" defer=""></script><script src="/log/_next/static/fteHFONwBJjAS3A9TnUR4/_buildManifest.js" defer=""></script><script src="/log/_next/static/fteHFONwBJjAS3A9TnUR4/_ssgManifest.js" defer=""></script><script src="/log/_next/static/fteHFONwBJjAS3A9TnUR4/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="min-h-screen"><main><div class="container mx-auto px-5"><h2 class="text-2xl md:text-4xl font-bold tracking-tight md:tracking-tighter leading-tight mb-20 mt-8"><a class="hover:underline" href="/log">Make üèóÔ∏è Devs</a></h2><article class="mb-32"><div class="-mb-36 md:-mb-36 sm:-mx-8"><div class="sm:mx-0"><img src="/log/img/cover.jpg" alt="Cover Image for The Good and Bad Parts of JS (according to Kyle Simpson)" class="responsive shadow-sm" width="310" height="160"/></div></div><h1 class="text-4xl md:text-5xl lg:text-6xl font-bold tracking-tighter leading-tight md:leading-none mb-12 text-center" style="transform:translateZ(0);background-image:radial-gradient(white 30%, transparent 50%)">The Good and Bad Parts of JS (according to Kyle Simpson)</h1><div class="mb-6 text-lg flex justify-around" style="transform:translateZ(0)"><time dateTime="2019-12-31T20:50:07.322Z">December	31, 2019</time><div class="flex items-center"><img src="/log/authors/jj.jpeg" class="w-12 h-12 rounded-full mr-4" alt="Jamie Vaughn"/><div class="text-xl font-bold">Jamie Vaughn</div></div></div><div class="max-w-2xl mx-auto"><div class="markdown-styles_markdown__h_8de"><p>Last time I summarized the good and bad parts of Javascript according to Douglas Crockford... Now I want to do the same according to Kyle Simpson, another Javascript expert I deeply respect. I gathered these opinions from several of Kyle Simpson's lecture on youtube and Linkedin Learning, especially his lectures on ES6, Coercion and Async Patterns.</p>
<h2>Some Bad Parts</h2>
<ol>
<li>The <code>new</code> keyword. Simpson advises to <em>never</em> use it, with only two exceptions: (1) <code>new Regex(&quot;a*b&quot;, &quot;i&quot;)</code> if you absolutely need dynamic regular expressions (other just use static <code>/a*b/i</code> syntax) and (2) `new Date() because that's the only way to get the date.</li>
<li><code>toString()</code> method on the Array &amp; Object natives since they return misleading values. Simpson recommends writing your own <code>toString()</code> methods in these two cases... i.e. calling the <code>JSON.stringify() method</code> as a custom <code>toString()</code> method on the Object prototype.</li>
</ol>
<h2>Some Overated Parts</h2>
<ol>
<li>The Arrow function is not widely needed... only for lexical scoping... i.e. binding <code>this</code> to outer scope
<blockquote>
<p>I disagree here but not all that strongly. I still use function declarations often for hoisting myself, but find concise arrow functions to be preferred whenever I reach for a function expression. And for callbacks, arrow functions are preferred. Simpson, himself, later on in the lectures I took this from, calls out several prominent use cases for the Arrow function, so this recommendation of his might be exaggerated.</p>
</blockquote>
</li>
<li>The &quot;Death of Var&quot;... in other words, <code>let</code> and <code>const</code> do not make <code>var</code> obsolete. It is still needed for cross scope accessibility</li>
<li><code>const</code> is actually not widely needed... (Protecting objects/properties is needed, but not loose variables so most times what you actually want is <code>Object.freeze</code>)</li>
</ol>
<h2>Some Good Parts</h2>
<ol>
<li>Type Coercion: Simpson recommends using explicit coercion whenever possible: <code>String()</code>, <code>Number()</code>, <code>Boolean()</code>. Don't use <code>toString()</code> or &quot;clever coercion&quot; like <code>+</code>, <code>!!</code></li>
<li><code>let</code> is great for its auto-closure in <code>for</code> loops and other block scopes (but still doesn't replace var)</li>
<li>Tagged Templates or Tag functions with Template strings... has led to many useful tag function libraries</li>
</ol>
<pre><code class="language-js">function greet() {
  return arguments;
}
var person = { name: &quot;Jon&quot;, age: 28 };
// A tagged template is a function call that uses a template literal from which to get its arguments
greet`I'm ${person.name}. I'm ${person.age} years old.`;
// Arguments: [['I'm ', '. I'm ', ' years old.'], 'Jon', 28]
</code></pre>
<ol start="4">
<li>Rest (&quot;gather&quot;) and Spread operators make JS syntax much more declarative</li>
<li>Default parameter values are awesome!! Default value can even be a function for logical defaults:</li>
</ol>
<pre><code class="language-js">function foo(id = generateID()) {
  //if foo is called with a user ID,
  //then a new ID is generated and assigned for the new user
}
//OR enforce a psuedo type with manual exceptions
const required = (param) =&gt; throw &quot;Missing required &quot; + param;
function foo(id = required(&quot;id&quot;)) {}
</code></pre>
<p>Default parameters can also be used in combination with the Rest operator and can be used safely with a function that returns an empty Array or Object as a default object assignment instead of using the conventional default assignment using <code>||</code>.</p>
<pre><code class="language-js">// old way
function printObj(obj) {
  let myObj = obj || {};
  console.log(myObj);
}
// new way with default params
function defaultPrint(obj = {}) {
  console.log(obj);
}
</code></pre>
<ol start="6">
<li>Generators... they are basically a state machine with lazy evaluation since it pauses between calls.</li>
</ol>
<pre><code class="language-js">// Can be coupled with while loops for endless generators:
function* uniqueID() {
  while (true) {
    yield Math.random();
  }
}
var num = () =&gt; uniqueID().next().value;
num();
</code></pre>
<blockquote>
<p>I love this take on generators. As long as we remember these generators are usually not pure functions we can still use them for a surprisingly large number of use cases. Since UI often tends to be best modeled as a finite state machine, generators can often model UI states very well.</p>
</blockquote>
</div></div></article></div><div class="text-center text-2xl my-16 underline"><a href="/log/posts">Read Another!</a></div></main></div><footer class="relative bg-accent-1 border-t border-accent-2"><div class="container mx-auto px-5"><div class="py-12 flex flex-col lg:flex-row items-center"><h3 class="text-4xl lg:text-5xl font-bold tracking-tighter leading-tight text-center lg:text-left mb-10 lg:mb-0 lg:pr-4 lg:w-1/2">Make üèóÔ∏è Devs</h3><div class="flex flex-col lg:flex-row justify-end items-center lg:pl-4 lg:w-1/2"><a href="https://wjv.io" class="mx-3 bg-black hover:bg-white hover:text-black border border-black text-white font-bold py-2 px-8 lg:px-8 duration-200 transition-colors mb-6 lg:mb-0">Portfolio</a><a href="https://github.com/JamieVaughn/log" class="mx-3 font-bold hover:underline">View on GitHub</a></div></div></div><span class="absolute bottom-1 right-2">graphics from <span class="underline"><a href="https://designs.ai/graphicmaker">designs.ai</a></span></span></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"The Good and Bad Parts of JS (according to Kyle Simpson)","date":"2019-12-31T20:50:07.322Z","slug":"good_parts_simpson","author":{"name":"Jamie Vaughn","picture":"/authors/jj.jpeg"},"content":"\u003cp\u003eLast time I summarized the good and bad parts of Javascript according to Douglas Crockford... Now I want to do the same according to Kyle Simpson, another Javascript expert I deeply respect. I gathered these opinions from several of Kyle Simpson's lecture on youtube and Linkedin Learning, especially his lectures on ES6, Coercion and Async Patterns.\u003c/p\u003e\n\u003ch2\u003eSome Bad Parts\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003eThe \u003ccode\u003enew\u003c/code\u003e keyword. Simpson advises to \u003cem\u003enever\u003c/em\u003e use it, with only two exceptions: (1) \u003ccode\u003enew Regex(\u0026quot;a*b\u0026quot;, \u0026quot;i\u0026quot;)\u003c/code\u003e if you absolutely need dynamic regular expressions (other just use static \u003ccode\u003e/a*b/i\u003c/code\u003e syntax) and (2) `new Date() because that's the only way to get the date.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etoString()\u003c/code\u003e method on the Array \u0026amp; Object natives since they return misleading values. Simpson recommends writing your own \u003ccode\u003etoString()\u003c/code\u003e methods in these two cases... i.e. calling the \u003ccode\u003eJSON.stringify() method\u003c/code\u003e as a custom \u003ccode\u003etoString()\u003c/code\u003e method on the Object prototype.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003eSome Overated Parts\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003eThe Arrow function is not widely needed... only for lexical scoping... i.e. binding \u003ccode\u003ethis\u003c/code\u003e to outer scope\n\u003cblockquote\u003e\n\u003cp\u003eI disagree here but not all that strongly. I still use function declarations often for hoisting myself, but find concise arrow functions to be preferred whenever I reach for a function expression. And for callbacks, arrow functions are preferred. Simpson, himself, later on in the lectures I took this from, calls out several prominent use cases for the Arrow function, so this recommendation of his might be exaggerated.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003cli\u003eThe \u0026quot;Death of Var\u0026quot;... in other words, \u003ccode\u003elet\u003c/code\u003e and \u003ccode\u003econst\u003c/code\u003e do not make \u003ccode\u003evar\u003c/code\u003e obsolete. It is still needed for cross scope accessibility\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econst\u003c/code\u003e is actually not widely needed... (Protecting objects/properties is needed, but not loose variables so most times what you actually want is \u003ccode\u003eObject.freeze\u003c/code\u003e)\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003eSome Good Parts\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003eType Coercion: Simpson recommends using explicit coercion whenever possible: \u003ccode\u003eString()\u003c/code\u003e, \u003ccode\u003eNumber()\u003c/code\u003e, \u003ccode\u003eBoolean()\u003c/code\u003e. Don't use \u003ccode\u003etoString()\u003c/code\u003e or \u0026quot;clever coercion\u0026quot; like \u003ccode\u003e+\u003c/code\u003e, \u003ccode\u003e!!\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elet\u003c/code\u003e is great for its auto-closure in \u003ccode\u003efor\u003c/code\u003e loops and other block scopes (but still doesn't replace var)\u003c/li\u003e\n\u003cli\u003eTagged Templates or Tag functions with Template strings... has led to many useful tag function libraries\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003efunction greet() {\n  return arguments;\n}\nvar person = { name: \u0026quot;Jon\u0026quot;, age: 28 };\n// A tagged template is a function call that uses a template literal from which to get its arguments\ngreet`I'm ${person.name}. I'm ${person.age} years old.`;\n// Arguments: [['I'm ', '. I'm ', ' years old.'], 'Jon', 28]\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003eRest (\u0026quot;gather\u0026quot;) and Spread operators make JS syntax much more declarative\u003c/li\u003e\n\u003cli\u003eDefault parameter values are awesome!! Default value can even be a function for logical defaults:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003efunction foo(id = generateID()) {\n  //if foo is called with a user ID,\n  //then a new ID is generated and assigned for the new user\n}\n//OR enforce a psuedo type with manual exceptions\nconst required = (param) =\u0026gt; throw \u0026quot;Missing required \u0026quot; + param;\nfunction foo(id = required(\u0026quot;id\u0026quot;)) {}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDefault parameters can also be used in combination with the Rest operator and can be used safely with a function that returns an empty Array or Object as a default object assignment instead of using the conventional default assignment using \u003ccode\u003e||\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003e// old way\nfunction printObj(obj) {\n  let myObj = obj || {};\n  console.log(myObj);\n}\n// new way with default params\nfunction defaultPrint(obj = {}) {\n  console.log(obj);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"6\"\u003e\n\u003cli\u003eGenerators... they are basically a state machine with lazy evaluation since it pauses between calls.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003e// Can be coupled with while loops for endless generators:\nfunction* uniqueID() {\n  while (true) {\n    yield Math.random();\n  }\n}\nvar num = () =\u0026gt; uniqueID().next().value;\nnum();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003eI love this take on generators. As long as we remember these generators are usually not pure functions we can still use them for a surprisingly large number of use cases. Since UI often tends to be best modeled as a finite state machine, generators can often model UI states very well.\u003c/p\u003e\n\u003c/blockquote\u003e\n","ogImage":{"url":"/img/cover.jpg"},"coverImage":"/img/cover.jpg"}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"good_parts_simpson"},"buildId":"fteHFONwBJjAS3A9TnUR4","assetPrefix":"/log","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>