<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png"/><link rel="manifest" href="/favicons/site.webmanifest"/><link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicons/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta name="description" content="Thoughts on our awesome collective web platform."/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>Nullish Checking in Javascript | Make Devs</title><meta property="og:image" content="/img/cover.jpg"/><meta name="next-head-count" content="16"/><link rel="preload" href="/log/_next/static/css/f59bbd0257d21d45.css" as="style"/><link rel="stylesheet" href="/log/_next/static/css/f59bbd0257d21d45.css" data-n-g=""/><link rel="preload" href="/log/_next/static/css/cf121497002c184d.css" as="style"/><link rel="stylesheet" href="/log/_next/static/css/cf121497002c184d.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/log/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/log/_next/static/chunks/webpack-c6d930e7ce3de825.js" defer=""></script><script src="/log/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/log/_next/static/chunks/main-b58ac34e0b98c3ee.js" defer=""></script><script src="/log/_next/static/chunks/pages/_app-90e414d931afb8eb.js" defer=""></script><script src="/log/_next/static/chunks/893-bb16ac16a245221e.js" defer=""></script><script src="/log/_next/static/chunks/349-6549a57f16834f01.js" defer=""></script><script src="/log/_next/static/chunks/pages/posts/%5Bslug%5D-527e0d774f36b704.js" defer=""></script><script src="/log/_next/static/obrXrIdU6aRWSbL_OwLjq/_buildManifest.js" defer=""></script><script src="/log/_next/static/obrXrIdU6aRWSbL_OwLjq/_ssgManifest.js" defer=""></script><script src="/log/_next/static/obrXrIdU6aRWSbL_OwLjq/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="min-h-screen"><main><div class="undefined container mx-auto px-5"><h2 class="text-2xl md:text-4xl font-bold tracking-tight md:tracking-tighter leading-tight mb-20 mt-8"><a class="hover:underline" href="/log">Make üèóÔ∏è Devs</a></h2><article class="mb-32"><div class="-mb-36 md:-mb-36 sm:-mx-8"><div class="sm:mx-0"><img src="/log//img/cover.jpg" alt="Cover Image for Nullish Checking in Javascript" class="responsive shadow-sm" width="310" height="160"/></div></div><h1 class="text-4xl md:text-5xl lg:text-6xl font-bold tracking-tighter leading-tight md:leading-none mb-12 text-center" style="transform:translateZ(0);background-image:radial-gradient(white 30%, transparent 50%)">Nullish Checking in Javascript</h1><div class="mb-6 text-lg flex justify-around" style="transform:translateZ(0)"><time dateTime="2022-02-11T11:25:07.322Z">February	11, 2022</time><div class="flex items-center"><img src="/log//authors/jj.jpeg" class="w-12 h-12 rounded-full mr-4" alt="Jamie Vaughn"/><div class="text-xl font-bold">Jamie Vaughn</div></div></div><div class="max-w-2xl mx-auto"><div class="markdown-styles_markdown__h_8de"><h2>What are Null Checks and What is Nullish?</h2>
<p>As programmers we often need to do some ad-hoc type checking for various reasons in our code. A common case is type checking of arguments passed into functions to make sure the subsequent operations and methods you use are supported by the argument type. One of the most frequent type checking needs is to make sure the parameters are not null, because null does not support any methods and will always throw an error if you try to chain any method off them. We call checking for null values &quot;Null Checking&quot;. In a simple case it would look something like this:</p>
<pre><code class="language-js">function stringify(param) {
  if (param === null) return &quot;nullish&quot;;
  return param.toString();
}
</code></pre>
<p>And we can't just test falsiness like this <code>if(!param)</code> because an empty string, zero or <code>false</code> would be valid values in this case. And in Javascript we also must consider the <code>undefined</code> value that most other languages don't need to consider. So the implementation gets slightly longer:</p>
<pre><code class="language-js">function stringify(param) {
  if (param === null || param === undefined) return &quot;nullish&quot;;
  return param.toString();
}
</code></pre>
<p>I am using the term &quot;Nullish Checking&quot; to refer to this kind of check for both <code>null</code> and <code>undefined</code> that is necessary in Javascript. The term borrows from the new nullish coalescing operator (<code>??</code>) added to the language in 2020.</p>
<p>So that doesn't seem like a big deal to write and one could even create a <code>nullishCheck</code> function to encapsulate it for better resuse:</p>
<pre><code class="language-js">function isNullish(param) {
  return param === null || param === undefined ? true : false;
}

function stringify(param) {
  if (isNullish(param)) return &quot;nullish&quot;;
  return param.toString();
}
</code></pre>
<p>That would be totally fine, but I like to see if the language actually supports these kind of things natively as an exercise in trying to explore &quot;idiomatic javascript&quot;, which is the notion of using the language features as they are whenever possible, rather than bolting on your own utilities.</p>
<h2>The valueOf trick</h2>
<p>As a result of that exploration I stumbled on what I call the <code>valueOf</code> nullish check. You can use the native javascript method <code>valueOf</code> in a slightly clever way to check if a value is not <code>null</code> or <code>undefined</code>.</p>
<pre><code class="language-js">function stringify(param) {
  if (!param?.valueOf) return &quot;nullish&quot;;
  return param.toString();
}
</code></pre>
<p>This leverages the optional chaining operator (which was also release to Javascript in 2020) and the native inherited Object method <code>valueOf</code>.</p>
<p>It is checking to see if the <code>param</code> value has the method <code>valueOf</code> on its prototype. All values, except <code>null</code> and <code>undefined</code> will inherit the <code>valueOf</code> method from the <code>Object</code> prototype, so all possible values will return an uninvoked function body when evaluating <code>param?.valueOf</code>. Then we use a <code>!</code> to coerce it to a boolean and flip the boolean as needed to exit the funciton early if <code>param</code> doesn't inherit <code>valueOf</code> and is therefore either <code>null</code> or <code>undefined</code>.</p>
<p>So our custom <code>isNullish(param)</code> utility and our native <code>!param?.valueOf</code> are almost equal number of characters (<code>isNullish</code> is one char longer, but the name could probably be shortened without losing legibility a bit), but <code>valueOf</code> leverages idiomatic Javascript by using a native method. And I would also go so far as to say it hits a semantically meaningful note to. The words &quot;value of&quot; do suggest it is checking for if there is something in that <code>param</code> rather than nothing, which is exaclty what a nullish check is intending to do. I think it's a pretty cool trick for the Javascript toolbox!</p>
<h2>The null Object Pitfall</h2>
<p>There is one catch though and it's one of those legitimate blemishes on Javascript as a language, in my opinion. It's <code>Object.create(null)</code>.</p>
<p><code>Object.create(null)</code> creates a Javascript <code>Object</code> that has no methods on its prototype. It's like an Object that came out of some void with no context to it or relationship to Javascript's normal prototypal inheritance chain.</p>
<p>So if we create an object this way it will not have the inherited method <code>valueOf</code> and it will appear to be nullish, even if we've added other methods to that object ourselves so it is an otherwise legitimate data structure.</p>
<pre><code class="language-js">const nullObj = Object.create(null);
const regularObj = Object.create({});

console.log(nullObj); // {}
console.log(nullObj.valueOf); // undefined
console.log(regularObj.valueOf); // {}
console.log(regularObj.valueOf); // ∆í valueOf() { [native code] }
</code></pre>
<p>I believe using <code>Object.create</code> this way is an anti-pattern and should never be done. Indeed, you'll never encounter a null Object in Javascript unless your code or code you import invokes the <code>Object.create(null)</code> code that way. However I have encountered a few libraries on npm that initialize objects like this, I suppose to reduce their size, so it is out these even if you never write that line yourself.</p>
<p>So you if you want to start using the <code>valueOf</code> trick for nullish checking you'll have to be on guard for libraries in your dependency chain that do this (and you'll have to make sure you don't do it either, of course, but that's easier to ensure). Luckily checking your dependencies for this pitfall isn't too difficult withmodern editors by just searching for the string <code>Object.create(null)</code> in your dependencies (node_modules) directory.</p>
<p>And to all you library authors out there, please reconsider reaching for the <code>Object.create(null)</code> anti-pattern! It's not worth it to save a few bytes! Thanks :)</p>
</div></div></article></div><div class="text-center text-2xl my-16 underline"><a href="/log/posts">Read Another!</a></div></main></div><footer class="relative bg-accent-1 border-t border-accent-2"><div class="undefined container mx-auto px-5"><div class="py-12 flex flex-col lg:flex-row items-center"><h3 class="text-4xl lg:text-5xl font-bold tracking-tighter leading-tight text-center lg:text-left mb-10 lg:mb-0 lg:pr-4 lg:w-1/2">Make üèóÔ∏è Devs</h3><div class="flex flex-col lg:flex-row justify-end items-center lg:pl-4 lg:w-1/2"><a href="https://wjv.io" class="mx-3 bg-black hover:bg-white hover:text-black border border-black text-white font-bold py-2 px-8 lg:px-8 duration-200 transition-colors mb-6 lg:mb-0">Portfolio</a><a href="https://github.com/JamieVaughn/log" class="mx-3 font-bold hover:underline">View on GitHub</a></div></div></div><span class="absolute bottom-1 right-2 text-xs">graphics from <span class="underline"><a href="https://designs.ai/graphicmaker">designs.ai</a></span></span></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"tags":["Javascript"],"title":"Nullish Checking in Javascript","date":"2022-02-11T11:25:07.322Z","slug":"nullish_checking_js","author":{"name":"Jamie Vaughn","picture":"/authors/jj.jpeg"},"content":"\u003ch2\u003eWhat are Null Checks and What is Nullish?\u003c/h2\u003e\n\u003cp\u003eAs programmers we often need to do some ad-hoc type checking for various reasons in our code. A common case is type checking of arguments passed into functions to make sure the subsequent operations and methods you use are supported by the argument type. One of the most frequent type checking needs is to make sure the parameters are not null, because null does not support any methods and will always throw an error if you try to chain any method off them. We call checking for null values \u0026quot;Null Checking\u0026quot;. In a simple case it would look something like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003efunction stringify(param) {\n  if (param === null) return \u0026quot;nullish\u0026quot;;\n  return param.toString();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd we can't just test falsiness like this \u003ccode\u003eif(!param)\u003c/code\u003e because an empty string, zero or \u003ccode\u003efalse\u003c/code\u003e would be valid values in this case. And in Javascript we also must consider the \u003ccode\u003eundefined\u003c/code\u003e value that most other languages don't need to consider. So the implementation gets slightly longer:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003efunction stringify(param) {\n  if (param === null || param === undefined) return \u0026quot;nullish\u0026quot;;\n  return param.toString();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eI am using the term \u0026quot;Nullish Checking\u0026quot; to refer to this kind of check for both \u003ccode\u003enull\u003c/code\u003e and \u003ccode\u003eundefined\u003c/code\u003e that is necessary in Javascript. The term borrows from the new nullish coalescing operator (\u003ccode\u003e??\u003c/code\u003e) added to the language in 2020.\u003c/p\u003e\n\u003cp\u003eSo that doesn't seem like a big deal to write and one could even create a \u003ccode\u003enullishCheck\u003c/code\u003e function to encapsulate it for better resuse:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003efunction isNullish(param) {\n  return param === null || param === undefined ? true : false;\n}\n\nfunction stringify(param) {\n  if (isNullish(param)) return \u0026quot;nullish\u0026quot;;\n  return param.toString();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThat would be totally fine, but I like to see if the language actually supports these kind of things natively as an exercise in trying to explore \u0026quot;idiomatic javascript\u0026quot;, which is the notion of using the language features as they are whenever possible, rather than bolting on your own utilities.\u003c/p\u003e\n\u003ch2\u003eThe valueOf trick\u003c/h2\u003e\n\u003cp\u003eAs a result of that exploration I stumbled on what I call the \u003ccode\u003evalueOf\u003c/code\u003e nullish check. You can use the native javascript method \u003ccode\u003evalueOf\u003c/code\u003e in a slightly clever way to check if a value is not \u003ccode\u003enull\u003c/code\u003e or \u003ccode\u003eundefined\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003efunction stringify(param) {\n  if (!param?.valueOf) return \u0026quot;nullish\u0026quot;;\n  return param.toString();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis leverages the optional chaining operator (which was also release to Javascript in 2020) and the native inherited Object method \u003ccode\u003evalueOf\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIt is checking to see if the \u003ccode\u003eparam\u003c/code\u003e value has the method \u003ccode\u003evalueOf\u003c/code\u003e on its prototype. All values, except \u003ccode\u003enull\u003c/code\u003e and \u003ccode\u003eundefined\u003c/code\u003e will inherit the \u003ccode\u003evalueOf\u003c/code\u003e method from the \u003ccode\u003eObject\u003c/code\u003e prototype, so all possible values will return an uninvoked function body when evaluating \u003ccode\u003eparam?.valueOf\u003c/code\u003e. Then we use a \u003ccode\u003e!\u003c/code\u003e to coerce it to a boolean and flip the boolean as needed to exit the funciton early if \u003ccode\u003eparam\u003c/code\u003e doesn't inherit \u003ccode\u003evalueOf\u003c/code\u003e and is therefore either \u003ccode\u003enull\u003c/code\u003e or \u003ccode\u003eundefined\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eSo our custom \u003ccode\u003eisNullish(param)\u003c/code\u003e utility and our native \u003ccode\u003e!param?.valueOf\u003c/code\u003e are almost equal number of characters (\u003ccode\u003eisNullish\u003c/code\u003e is one char longer, but the name could probably be shortened without losing legibility a bit), but \u003ccode\u003evalueOf\u003c/code\u003e leverages idiomatic Javascript by using a native method. And I would also go so far as to say it hits a semantically meaningful note to. The words \u0026quot;value of\u0026quot; do suggest it is checking for if there is something in that \u003ccode\u003eparam\u003c/code\u003e rather than nothing, which is exaclty what a nullish check is intending to do. I think it's a pretty cool trick for the Javascript toolbox!\u003c/p\u003e\n\u003ch2\u003eThe null Object Pitfall\u003c/h2\u003e\n\u003cp\u003eThere is one catch though and it's one of those legitimate blemishes on Javascript as a language, in my opinion. It's \u003ccode\u003eObject.create(null)\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eObject.create(null)\u003c/code\u003e creates a Javascript \u003ccode\u003eObject\u003c/code\u003e that has no methods on its prototype. It's like an Object that came out of some void with no context to it or relationship to Javascript's normal prototypal inheritance chain.\u003c/p\u003e\n\u003cp\u003eSo if we create an object this way it will not have the inherited method \u003ccode\u003evalueOf\u003c/code\u003e and it will appear to be nullish, even if we've added other methods to that object ourselves so it is an otherwise legitimate data structure.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003econst nullObj = Object.create(null);\nconst regularObj = Object.create({});\n\nconsole.log(nullObj); // {}\nconsole.log(nullObj.valueOf); // undefined\nconsole.log(regularObj.valueOf); // {}\nconsole.log(regularObj.valueOf); // ∆í valueOf() { [native code] }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eI believe using \u003ccode\u003eObject.create\u003c/code\u003e this way is an anti-pattern and should never be done. Indeed, you'll never encounter a null Object in Javascript unless your code or code you import invokes the \u003ccode\u003eObject.create(null)\u003c/code\u003e code that way. However I have encountered a few libraries on npm that initialize objects like this, I suppose to reduce their size, so it is out these even if you never write that line yourself.\u003c/p\u003e\n\u003cp\u003eSo you if you want to start using the \u003ccode\u003evalueOf\u003c/code\u003e trick for nullish checking you'll have to be on guard for libraries in your dependency chain that do this (and you'll have to make sure you don't do it either, of course, but that's easier to ensure). Luckily checking your dependencies for this pitfall isn't too difficult withmodern editors by just searching for the string \u003ccode\u003eObject.create(null)\u003c/code\u003e in your dependencies (node_modules) directory.\u003c/p\u003e\n\u003cp\u003eAnd to all you library authors out there, please reconsider reaching for the \u003ccode\u003eObject.create(null)\u003c/code\u003e anti-pattern! It's not worth it to save a few bytes! Thanks :)\u003c/p\u003e\n","ogImage":{"url":"/img/cover.jpg"},"coverImage":"/img/cover.jpg"}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"nullish_checking_js"},"buildId":"obrXrIdU6aRWSbL_OwLjq","assetPrefix":"/log","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>