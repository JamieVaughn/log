<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png"/><link rel="manifest" href="/favicons/site.webmanifest"/><link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicons/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta name="description" content="Thoughts on our awesome collective web platform."/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>Javascript&#x27;s Immutability Toolkit | Make Devs</title><meta property="og:image" content="/img/cover.jpg"/><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/9cc228776be9975c.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9cc228776be9975c.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cf121497002c184d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cf121497002c184d.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-9b312e20a4e32339.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-83803dd478f5b5bc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-90e414d931afb8eb.js" defer=""></script><script src="/_next/static/chunks/893-bb16ac16a245221e.js" defer=""></script><script src="/_next/static/chunks/349-6549a57f16834f01.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-526ce38baf3fe719.js" defer=""></script><script src="/_next/static/oc3N0y__jbrQdJAhe2PJR/_buildManifest.js" defer=""></script><script src="/_next/static/oc3N0y__jbrQdJAhe2PJR/_ssgManifest.js" defer=""></script><script src="/_next/static/oc3N0y__jbrQdJAhe2PJR/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="min-h-screen"><main><div class="container mx-auto px-5"><h2 class="text-2xl md:text-4xl font-bold tracking-tight md:tracking-tighter leading-tight mb-20 mt-8"><a class="hover:underline" href="/">Make üèóÔ∏è Devs</a></h2><article class="mb-32"><div class="-mb-36 md:-mb-36 sm:-mx-8"><div class="sm:mx-0"><img src="/img/cover.jpg" alt="Cover Image for Javascript&#x27;s Immutability Toolkit" class="responsive shadow-sm" width="310" height="160"/></div></div><h1 class="text-4xl md:text-5xl lg:text-6xl font-bold tracking-tighter leading-tight md:leading-none mb-12 text-center" style="transform:translateZ(0);background-image:radial-gradient(white 30%, transparent 50%)">Javascript&#x27;s Immutability Toolkit</h1><div class="mb-6 text-lg flex justify-around" style="transform:translateZ(0)"><time dateTime="2020-12-21T12:35:07.322Z">December	21, 2020</time><div class="flex items-center"><img src="/authors/jj.jpeg" class="w-12 h-12 rounded-full mr-4" alt="Jamie Vaughn"/><div class="text-xl font-bold">Jamie Vaughn</div></div></div><div class="max-w-2xl mx-auto"><div class="markdown-styles_markdown__h_8de"><p>We'll survey the various methods available natively in JS that allow us to manipulate data without mutating it in place.</p>
<p>In the functional programming paradigm, avoiding mutation of data or state in your application is an important prinicple that helps us to avoid a certain class of bugs related to side effects and state. Maintaining immutibility during data manipulation can help with:</p>
<ul>
<li>State management</li>
<li>Pure Functions</li>
<li>Race Conditions</li>
<li>Developer Experience (DX)</li>
</ul>
<p>When mutating data in place, there is a strong risk that some other piece of the application is still depending on that data's previous state and may break due to that data mutating. By using immutable methods, you can simply make copies of the application state, applying the changes to that copy, and then pass the new copy to the funciton or method that needs to use it, without worrying about other parts of the application being affected by that change unknowingly.</p>
<p>This immutability principle is preferred in the React community when creating internal component state and also when using Redux for managing global state.</p>
<p>The only real downside is that it uses more memory... but memory isn't in short supply with today's hardware. And the improvement in the DX, by making state management more easily understandable far outweighs that downside, in my opinion.</p>
<h2>Favor Non-Mutating Methods</h2>
<p>Here is a list of JS arrays methods and a few other ways to manipulate data in a non-mutating way:</p>
<pre><code class="language-js">const arr = [1]
arr.slice() // prefer .slice over .splice and for general array copying
arr.flat()
arr.concat() // prefer .concat over .push
arr.map() // prefer .map over .forEach
arr.flatMap()
arr.filter()
arr.reduce()
arr.reduceRight()
arr.some()
arr.every()
arr.find()
arr.findIndex()
arr.join()
arr.toString()
[...arr, 4, 5]
Object.keys, .values. entries() // to manipulate Object as Array then convert back
Object.assign({}, obj)
Object.freeze()
</code></pre>
<p>Check MDN's <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from#">Array methods in the side bar on the left</a> for an exhaustive list.</p>
<p>Pure functions are a central part of data immutability. Pure functions are the canonical black box that simply inputs something and returns some transformation of that input. Input, Output... no side effects. This also tends to keep the functions simple, which improves DX.
A pure function:</p>
<pre><code class="language-js">function square(num) {
  return num ** 2;
}
</code></pre>
<p>Now, obviously for an application to be useful, it has to execute side effects at some point. The idea behind pure functions and immutability is to isolate those effectful parts of the program into as small a space as possible and ensure that the largest amount of the program abides by the immutability principles.</p>
<h2>Avoid Mutating Methods</h2>
<p>Let's briefly mention some of the common mutating methods in JS that you would be advised to avoid by default. There are, of course, circumstances in which these methods should be used, but they should not be the first choice, in general. Consider only using these methods in the isolated edges of your application into which you are segregating your side effects. They also may be needed as a last resort when immutability is not feasible.</p>
<pre><code class="language-js">arr.push();
arr.pop();
arr.shift();
arr.unshift();
arr.splice();
arr.sort(); // to adapt this to immutability, use .slice(0).sort() or [...arr].sort()
arr.reverse();
arr.copyWithin();
arr.forEach();
Object.create(); // Mutating in the sense that it inherits prototype properties which can be overwritten
</code></pre>
<p>One note about <code>forEach()</code>: This is the prefered way in the functional paradigm to implement for loops that execute side effects. But for most cases that need loops, <code>map()</code>, <code>filter()</code> and <code>reduce()</code> are the preferred methods.</p>
<h2>Object.freeze() &amp; const</h2>
<p>To protect variables' mutability, JS now has the <code>const</code> keyword. a variable declared with <code>const</code> will be treated as a constant and it will not be able to be overwritten or re-declared. For imuutability reasons, we will want to prefer using <code>const</code> over using <code>let</code> or <code>var</code>. Of course, there will always be reasons to use <code>let</code> in cases that you must be able to re-declare a variable, and that's fine. And there will even be cases to use <code>var</code> for hoisting reasons, for example, and that is also fine. But in general, default to using <code>const</code> unless you find that you positively need one of the other two.</p>
<p>One limitation of the <code>const</code> keyword is that it does not prevent overwritting of values in nested data structures like objects and arrays.</p>
<pre><code class="language-js">const myNum = 5;
myNum = 6; // Throws TypeError, myNum is protected from mutation
const myNum = 6; // Throws SyntaxError, myNum can't be re-declared/re-initialized

const myObj = {
  num: 5,
};
myObj = [6]; // Throws TypeError, myObj is protected from mutation
myObj.num = 6; // this is permitted, the properties within myObj are not protected
</code></pre>
<p>The way to protect neseted data in an object is to use <code>Object.freeze</code>. And since arrays are also objects, this can be used on arrays as well. Here's an example:</p>
<pre><code class="language-js">const myObj = {
  num: 5,
  nested: {
    num: 1,
  },
};
Object.freeze(myObj);
myObj.num = 6; // JS will silently ignore this, now the internal properties are also protected
console.log(myObj.num); // 5

const myArr = [1, 2, [3, 4]];
Object.freeze(myArr);
myArr[0] = 9; // JS will silently ignore this, now the internal values are also protected
</code></pre>
<p>Object.freeze has a serious limitation, though and that is that it only freezes an object shallowly:</p>
<pre><code class="language-js">myObj.nested.num = 9; // this will mutate that property form 1 to 9
console.log(myObj.num); // 9
myArr[2][0] = 9; // this will mutate that property from 3 to 9
console.log(myArr[2][0]); // 9
</code></pre>
<p>In other words, it only protects to the first level of nesting. So in order to protect all of an arbitrarily nested object or array, you'll have to use a loop or recursion to reach the inner nested objects and freeze each of those as well. This is referred to as a &quot;deep freeze.&quot; And rather than try to write your own algorithm to do it, you can use a small library such as <a href="https://github.com/substack/deep-freeze">this one</a> which has been tested and used safely for many years. However if you really want to implement a simple deep freeze method yourself, it could look something like this:</p>
<pre><code class="language-js">const obj = {
      name: &quot;Bob&quot;,
      job: {
        title : &quot;Worker&quot;
        employees: {
          &quot;Phil&quot;: {
            title: &quot;Secretary&quot;
          }
        }
      }
   };

function deepFreeze(obj){
  if(typeof obj !== 'object') return; // escape condition... no more nesting is detected
  Object.values(obj).forEach(deepFreeze) // recursively apply deepfreeze
  Object.freeze(obj);
}

deepFreeze(obj);

obj.job.title = &quot;CEO&quot; // Will silently fail
obj.job.employees.Phil.title = &quot;programmer&quot; // will silently fail
console.log(obj.job.title) // &quot;Worker&quot;
console.log(obj.job.employees.Phil.title) // &quot;secretary&quot;
</code></pre>
<h2>The Proposal for Records and Tuples</h2>
<p>In TC39 (A committee overseeing feature additions to JS) there is a <a href="https://github.com/tc39/proposal-record-tuple">proposal</a> to add two deeply immutable data types to the Javascript language: Records and Tuples. A record would essentially be a deeply immutable object and a tuple would essentially be a deeply immutable array.</p>
<pre><code class="language-js">#{ x: 1, y: 2 }; // Record
#[1, 2, 3, 4]; // Tuple
</code></pre>
<p>These would be a welcome addition to Javascript in general and to the immutability toolkit in particular. It would remove the need for utility libraries like the deep-freeze library discussed above, and even mostly or entirely remove the need for <code>Object.freeze</code>, because now we would have deeply immutable object natively.</p>
<h2>Cautionary Tale</h2>
<p>I've run across a particularly hard to diagnose bug related to mutability in an application of mine. I was creating an array for a game board using <code>Array(10).fill({id: 0})</code>, with the intention that every space on the game board would have a unique object that I could update with game state. Unfortunately, when the <code>.fill</code> method is passed an object, it creates an array where every element is a reference to that same passed object in memory. So as I updated one space in the game state of the board (i.e. one position of that array), every space was mutated with that data, not just the one space I was targeting. It was a very weird bug that was hard to track at first, especially if you don't know about immutability and objects being passed by reference. So if you plan to try to use objects as independent state, you will want to go to the effort of copying the objects immutably and passing the copies around, and not the references. Thankfully with our immutability toolkit, we can now use our trusty <code>.map()</code> method to help us here:</p>
<pre><code class="language-js">Array(10)
  .fill(0)
  .map((item, index) =&gt; ({ id: index }));
// this will create unique objects in each position of the array.
</code></pre>
<p>Using <code>.from()</code> is an alternative method to accomplish the same thing, because it accepts a callback function as the second argument to fill the values with. So you can pass a callback that returns an object, and each object will be a unique object in memory.</p>
<pre><code class="language-js">Array.from({ length: 10 }, (_, index) =&gt; ({ id: index }));
// the second argument in the callback will be the index
</code></pre>
</div></div></article></div><div class="text-center text-2xl my-16 underline"><a href="/posts">Read Another!</a></div></main></div><footer class="relative bg-accent-1 border-t border-accent-2"><div class="container mx-auto px-5"><div class="py-12 flex flex-col lg:flex-row items-center"><h3 class="text-4xl lg:text-5xl font-bold tracking-tighter leading-tight text-center lg:text-left mb-10 lg:mb-0 lg:pr-4 lg:w-1/2">Make üèóÔ∏è Devs</h3><div class="flex flex-col lg:flex-row justify-end items-center lg:pl-4 lg:w-1/2"><a href="https://wjv.io" class="mx-3 bg-black hover:bg-white hover:text-black border border-black text-white font-bold py-2 px-8 lg:px-8 duration-200 transition-colors mb-6 lg:mb-0">Portfolio</a><a href="https://github.com/JamieVaughn/log" class="mx-3 font-bold hover:underline">View on GitHub</a></div></div></div><span class="absolute bottom-1 right-2">graphics from <span class="underline"><a href="https://designs.ai/graphicmaker">designs.ai</a></span></span></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Javascript's Immutability Toolkit","date":"2020-12-21T12:35:07.322Z","slug":"immutability","author":{"name":"Jamie Vaughn","picture":"/authors/jj.jpeg"},"content":"\u003cp\u003eWe'll survey the various methods available natively in JS that allow us to manipulate data without mutating it in place.\u003c/p\u003e\n\u003cp\u003eIn the functional programming paradigm, avoiding mutation of data or state in your application is an important prinicple that helps us to avoid a certain class of bugs related to side effects and state. Maintaining immutibility during data manipulation can help with:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eState management\u003c/li\u003e\n\u003cli\u003ePure Functions\u003c/li\u003e\n\u003cli\u003eRace Conditions\u003c/li\u003e\n\u003cli\u003eDeveloper Experience (DX)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhen mutating data in place, there is a strong risk that some other piece of the application is still depending on that data's previous state and may break due to that data mutating. By using immutable methods, you can simply make copies of the application state, applying the changes to that copy, and then pass the new copy to the funciton or method that needs to use it, without worrying about other parts of the application being affected by that change unknowingly.\u003c/p\u003e\n\u003cp\u003eThis immutability principle is preferred in the React community when creating internal component state and also when using Redux for managing global state.\u003c/p\u003e\n\u003cp\u003eThe only real downside is that it uses more memory... but memory isn't in short supply with today's hardware. And the improvement in the DX, by making state management more easily understandable far outweighs that downside, in my opinion.\u003c/p\u003e\n\u003ch2\u003eFavor Non-Mutating Methods\u003c/h2\u003e\n\u003cp\u003eHere is a list of JS arrays methods and a few other ways to manipulate data in a non-mutating way:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003econst arr = [1]\narr.slice() // prefer .slice over .splice and for general array copying\narr.flat()\narr.concat() // prefer .concat over .push\narr.map() // prefer .map over .forEach\narr.flatMap()\narr.filter()\narr.reduce()\narr.reduceRight()\narr.some()\narr.every()\narr.find()\narr.findIndex()\narr.join()\narr.toString()\n[...arr, 4, 5]\nObject.keys, .values. entries() // to manipulate Object as Array then convert back\nObject.assign({}, obj)\nObject.freeze()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCheck MDN's \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from#\"\u003eArray methods in the side bar on the left\u003c/a\u003e for an exhaustive list.\u003c/p\u003e\n\u003cp\u003ePure functions are a central part of data immutability. Pure functions are the canonical black box that simply inputs something and returns some transformation of that input. Input, Output... no side effects. This also tends to keep the functions simple, which improves DX.\nA pure function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003efunction square(num) {\n  return num ** 2;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, obviously for an application to be useful, it has to execute side effects at some point. The idea behind pure functions and immutability is to isolate those effectful parts of the program into as small a space as possible and ensure that the largest amount of the program abides by the immutability principles.\u003c/p\u003e\n\u003ch2\u003eAvoid Mutating Methods\u003c/h2\u003e\n\u003cp\u003eLet's briefly mention some of the common mutating methods in JS that you would be advised to avoid by default. There are, of course, circumstances in which these methods should be used, but they should not be the first choice, in general. Consider only using these methods in the isolated edges of your application into which you are segregating your side effects. They also may be needed as a last resort when immutability is not feasible.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003earr.push();\narr.pop();\narr.shift();\narr.unshift();\narr.splice();\narr.sort(); // to adapt this to immutability, use .slice(0).sort() or [...arr].sort()\narr.reverse();\narr.copyWithin();\narr.forEach();\nObject.create(); // Mutating in the sense that it inherits prototype properties which can be overwritten\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOne note about \u003ccode\u003eforEach()\u003c/code\u003e: This is the prefered way in the functional paradigm to implement for loops that execute side effects. But for most cases that need loops, \u003ccode\u003emap()\u003c/code\u003e, \u003ccode\u003efilter()\u003c/code\u003e and \u003ccode\u003ereduce()\u003c/code\u003e are the preferred methods.\u003c/p\u003e\n\u003ch2\u003eObject.freeze() \u0026amp; const\u003c/h2\u003e\n\u003cp\u003eTo protect variables' mutability, JS now has the \u003ccode\u003econst\u003c/code\u003e keyword. a variable declared with \u003ccode\u003econst\u003c/code\u003e will be treated as a constant and it will not be able to be overwritten or re-declared. For imuutability reasons, we will want to prefer using \u003ccode\u003econst\u003c/code\u003e over using \u003ccode\u003elet\u003c/code\u003e or \u003ccode\u003evar\u003c/code\u003e. Of course, there will always be reasons to use \u003ccode\u003elet\u003c/code\u003e in cases that you must be able to re-declare a variable, and that's fine. And there will even be cases to use \u003ccode\u003evar\u003c/code\u003e for hoisting reasons, for example, and that is also fine. But in general, default to using \u003ccode\u003econst\u003c/code\u003e unless you find that you positively need one of the other two.\u003c/p\u003e\n\u003cp\u003eOne limitation of the \u003ccode\u003econst\u003c/code\u003e keyword is that it does not prevent overwritting of values in nested data structures like objects and arrays.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003econst myNum = 5;\nmyNum = 6; // Throws TypeError, myNum is protected from mutation\nconst myNum = 6; // Throws SyntaxError, myNum can't be re-declared/re-initialized\n\nconst myObj = {\n  num: 5,\n};\nmyObj = [6]; // Throws TypeError, myObj is protected from mutation\nmyObj.num = 6; // this is permitted, the properties within myObj are not protected\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe way to protect neseted data in an object is to use \u003ccode\u003eObject.freeze\u003c/code\u003e. And since arrays are also objects, this can be used on arrays as well. Here's an example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003econst myObj = {\n  num: 5,\n  nested: {\n    num: 1,\n  },\n};\nObject.freeze(myObj);\nmyObj.num = 6; // JS will silently ignore this, now the internal properties are also protected\nconsole.log(myObj.num); // 5\n\nconst myArr = [1, 2, [3, 4]];\nObject.freeze(myArr);\nmyArr[0] = 9; // JS will silently ignore this, now the internal values are also protected\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eObject.freeze has a serious limitation, though and that is that it only freezes an object shallowly:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003emyObj.nested.num = 9; // this will mutate that property form 1 to 9\nconsole.log(myObj.num); // 9\nmyArr[2][0] = 9; // this will mutate that property from 3 to 9\nconsole.log(myArr[2][0]); // 9\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn other words, it only protects to the first level of nesting. So in order to protect all of an arbitrarily nested object or array, you'll have to use a loop or recursion to reach the inner nested objects and freeze each of those as well. This is referred to as a \u0026quot;deep freeze.\u0026quot; And rather than try to write your own algorithm to do it, you can use a small library such as \u003ca href=\"https://github.com/substack/deep-freeze\"\u003ethis one\u003c/a\u003e which has been tested and used safely for many years. However if you really want to implement a simple deep freeze method yourself, it could look something like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003econst obj = {\n      name: \u0026quot;Bob\u0026quot;,\n      job: {\n        title : \u0026quot;Worker\u0026quot;\n        employees: {\n          \u0026quot;Phil\u0026quot;: {\n            title: \u0026quot;Secretary\u0026quot;\n          }\n        }\n      }\n   };\n\nfunction deepFreeze(obj){\n  if(typeof obj !== 'object') return; // escape condition... no more nesting is detected\n  Object.values(obj).forEach(deepFreeze) // recursively apply deepfreeze\n  Object.freeze(obj);\n}\n\ndeepFreeze(obj);\n\nobj.job.title = \u0026quot;CEO\u0026quot; // Will silently fail\nobj.job.employees.Phil.title = \u0026quot;programmer\u0026quot; // will silently fail\nconsole.log(obj.job.title) // \u0026quot;Worker\u0026quot;\nconsole.log(obj.job.employees.Phil.title) // \u0026quot;secretary\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eThe Proposal for Records and Tuples\u003c/h2\u003e\n\u003cp\u003eIn TC39 (A committee overseeing feature additions to JS) there is a \u003ca href=\"https://github.com/tc39/proposal-record-tuple\"\u003eproposal\u003c/a\u003e to add two deeply immutable data types to the Javascript language: Records and Tuples. A record would essentially be a deeply immutable object and a tuple would essentially be a deeply immutable array.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003e#{ x: 1, y: 2 }; // Record\n#[1, 2, 3, 4]; // Tuple\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThese would be a welcome addition to Javascript in general and to the immutability toolkit in particular. It would remove the need for utility libraries like the deep-freeze library discussed above, and even mostly or entirely remove the need for \u003ccode\u003eObject.freeze\u003c/code\u003e, because now we would have deeply immutable object natively.\u003c/p\u003e\n\u003ch2\u003eCautionary Tale\u003c/h2\u003e\n\u003cp\u003eI've run across a particularly hard to diagnose bug related to mutability in an application of mine. I was creating an array for a game board using \u003ccode\u003eArray(10).fill({id: 0})\u003c/code\u003e, with the intention that every space on the game board would have a unique object that I could update with game state. Unfortunately, when the \u003ccode\u003e.fill\u003c/code\u003e method is passed an object, it creates an array where every element is a reference to that same passed object in memory. So as I updated one space in the game state of the board (i.e. one position of that array), every space was mutated with that data, not just the one space I was targeting. It was a very weird bug that was hard to track at first, especially if you don't know about immutability and objects being passed by reference. So if you plan to try to use objects as independent state, you will want to go to the effort of copying the objects immutably and passing the copies around, and not the references. Thankfully with our immutability toolkit, we can now use our trusty \u003ccode\u003e.map()\u003c/code\u003e method to help us here:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003eArray(10)\n  .fill(0)\n  .map((item, index) =\u0026gt; ({ id: index }));\n// this will create unique objects in each position of the array.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUsing \u003ccode\u003e.from()\u003c/code\u003e is an alternative method to accomplish the same thing, because it accepts a callback function as the second argument to fill the values with. So you can pass a callback that returns an object, and each object will be a unique object in memory.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003eArray.from({ length: 10 }, (_, index) =\u0026gt; ({ id: index }));\n// the second argument in the callback will be the index\n\u003c/code\u003e\u003c/pre\u003e\n","ogImage":{"url":"/img/cover.jpg"},"coverImage":"/img/cover.jpg"}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"immutability"},"buildId":"oc3N0y__jbrQdJAhe2PJR","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>