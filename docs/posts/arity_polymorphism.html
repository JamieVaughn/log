<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png"/><link rel="manifest" href="/favicons/site.webmanifest"/><link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicons/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta name="description" content="Thoughts on our awesome collective web platform."/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>Variadic Functions in Javascript | Make Devs</title><meta property="og:image" content="/img/cover.jpg"/><meta name="next-head-count" content="16"/><link rel="preload" href="/log/_next/static/css/a7c488a3d94a7e0a.css" as="style"/><link rel="stylesheet" href="/log/_next/static/css/a7c488a3d94a7e0a.css" data-n-g=""/><link rel="preload" href="/log/_next/static/css/cf121497002c184d.css" as="style"/><link rel="stylesheet" href="/log/_next/static/css/cf121497002c184d.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/log/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/log/_next/static/chunks/webpack-c6d930e7ce3de825.js" defer=""></script><script src="/log/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/log/_next/static/chunks/main-b58ac34e0b98c3ee.js" defer=""></script><script src="/log/_next/static/chunks/pages/_app-90e414d931afb8eb.js" defer=""></script><script src="/log/_next/static/chunks/893-bb16ac16a245221e.js" defer=""></script><script src="/log/_next/static/chunks/349-6549a57f16834f01.js" defer=""></script><script src="/log/_next/static/chunks/pages/posts/%5Bslug%5D-b92481cdf92bcf57.js" defer=""></script><script src="/log/_next/static/pV2irWljyY_HBH9QdnYAB/_buildManifest.js" defer=""></script><script src="/log/_next/static/pV2irWljyY_HBH9QdnYAB/_ssgManifest.js" defer=""></script><script src="/log/_next/static/pV2irWljyY_HBH9QdnYAB/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="min-h-screen"><main><div class="container mx-auto px-5"><h2 class="text-2xl md:text-4xl font-bold tracking-tight md:tracking-tighter leading-tight mb-20 mt-8"><a class="hover:underline" href="/log">Make üèóÔ∏è Devs</a></h2><article class="mb-32"><div class="-mb-36 md:-mb-36 sm:-mx-8"><div class="sm:mx-0"><img src="/log//img/cover.jpg" alt="Cover Image for Variadic Functions in Javascript" class="responsive shadow-sm" width="310" height="160"/></div></div><h1 class="text-4xl md:text-5xl lg:text-6xl font-bold tracking-tighter leading-tight md:leading-none mb-12 text-center" style="transform:translateZ(0);background-image:radial-gradient(white 30%, transparent 50%)">Variadic Functions in Javascript</h1><div class="mb-6 text-lg flex justify-around" style="transform:translateZ(0)"><time dateTime="2021-01-22T05:35:07.322Z">January	22, 2021</time><div class="flex items-center"><img src="/log//authors/jj.jpeg" class="w-12 h-12 rounded-full mr-4" alt="Jamie Vaughn"/><div class="text-xl font-bold">Jamie Vaughn</div></div></div><div class="max-w-2xl mx-auto"><div class="markdown-styles_markdown__h_8de"><p>A Variadic Function describes a function that executes different logic depending on the arity, or the number of parameters passed to it. It is also called called function-overloading sometimes, mostly by detractors of this pattern. But this is a feature in many languages, especially functional paradigm languages. Languages like Elixir, Scheme and even Python support it.</p>
<p>While Javascript does not have this as a first-class capability, I'll demonstrate how to work within Javascript's constraints to create a variadic function.</p>
<h2>Example Use Case</h2>
<p>Let's imagine we want to implement a function that logs client-side events for us in a few different ways. We want it to be able to log a simple message or a message with a priority rating or log to our server using a service, depending on how many arguments are provided. One option is to define three different functions to accomplish this and call each one separately as the case may necessitate it. While there isn't anything necessarily wrong with that, it does present a non-consistent API surface with which to work with. What if we want to call just one logging function no matter which scenario, and let the function handle which internal logging logic to execute? And furthermore we want to do it in a way that avoids the cyclomatic complexity of <code>if</code>-<code>else</code> statements...</p>
<p>We could create such a function by leveraging Javascript's array data structure and map the the number of arguments passed to the function to an array position, which would hold the executable logic appropriate for that arity. The array is accessed by arity (minus one) and invoked and then it is returned. Let's take a look at what such a variadic function (we'll call it <code>polyLog</code>) might look like:</p>
<pre><code class="language-js">// We have some library/service that logs to a server via API call
const serverObj = {
  log: (msg) =&gt; Server.log(msg + &quot; ...Logged to Server API.&quot;),
};

// here is our variadic function
function polyLog(msg, priority, dest) {
  return [
    () =&gt; console.log(msg),
    () =&gt; console.log(`[${priority}] ${msg}`),
    () =&gt; dest.log(`[${priority}] ${msg}`),
  ][arguments.length - 1]();
}

// you can call it 3 ways for 3 different results
polyLog(&quot;msg&quot;);
polyLog(&quot;msg&quot;, 5);
polyLog(&quot;msg&quot;, 5, serverObj);
</code></pre>
<p>So you can see we've leveraged a Javascript array and the fact that the number of parameters passed to a function is exposed via the <code>arguments</code> keyword within the function body. The appropriate index of the array is accessed with <code>arguments.length - 1</code> so the array evaluates to the associated sub-function. The order of the sub-functions in the array must be carefully chosen to correspond with the arguments they need. That part is up the developer to ensure.</p>
<p>Encapsulating all of this logging functionality inside one function not only conveniently reduces the API surface for us, but it just makes more sense since it is all related behavior. It also improves maintainability by keeping the function definitions of all possible logging behavior co-located in one data structure. And during refactors, one fix ought to automatically propogate to all invocations of <code>polyLog</code> within the app.</p>
<h2>Some Refactoring</h2>
<p>The previous section describes the crux of the idea and accomplishes our goal of a variadic, but let's see if we can clean up or improve that code at all.</p>
<p>The first refactoring opportunity is to use function expressions instead of defining the functions inside the returned array. So lets define our logging functions above our <code>polyLog</code> function like so:</p>
<pre><code class="language-js">const simpleLog = (msg) =&gt; console.log(msg);
const priorityLog = (msg, priority) =&gt; console.log(`[${priority}] ${msg}`);
const serverLog = (msg, priority, dest) =&gt; dest.log(`[${priority}] ${msg}`);
</code></pre>
<p>You'll notice one other necessary change to the sub-functions: We are passing the parameters through now, since they won't be available from the parent scope anymore.</p>
<p>We can also make a small memory optimization by defining our array of functions externally and referencing it in our variadic <code>polyLog</code> function:</p>
<pre><code class="language-js">// this external array becomes our function-arity map
const arityMap = [simpleLog, priorityLog, serverLog];

// Now polyLog is a wrapping interface for our function-arity map
const polyLog = function (msg, priority, dest) {
  return arityMap[arguments.length - 1](msg, priority, dest);
};
</code></pre>
<p>So now the array of sub-functions is defined once instead of each time <code>polyLog</code> is invoked, which saves on memory. And our function is also mostly just an abstraction layer wrapping our array that serves as our function-arity map.</p>
<h3>Note On Arrow Functions</h3>
<p>It's important to note, this technique doesn't really work with arrow functions as they do not contain a reference to <code>arguments</code> in their function body. However, there is a hacky workaround by using the spread operator, although this should be avoided as the parameters necessarily will lose all or most of their semantic meaning.</p>
<pre><code class="language-js">const arityMap = [simpleLog, priorityLog, serverLog];
const polyLog = (...args) =&gt; arityMap[args.length - 1](...args);
// Because we spread on args, we don't know what each parameter is called anymore
</code></pre>
<h2>More Abstraction</h2>
<p>Now that <code>polyLog</code> has been abstracted in the &quot;Some Refactoring&quot; section, it is starting to look more like a general API surface. But let's try to abstract it further. What if we allow the function-arity array to be passed in as a parameter as well so that we can define one <code>variadic</code> function that could allow any array of functions be invoked with indefinite arity?</p>
<pre><code class="language-js">function variadic(array, ...args) {
  const arity = args.filter((a) =&gt; a !== undefined).length;
  return array[arity - 1](...args);
}
</code></pre>
<p>A trade-off that has to be made here is spreading the <code>args</code> out because for this abstract case, we will not know how many parameters the functions will be needing. And so it suffers from not being able to make use of the <code>arguments</code> keyword as before. Instead we have to filter the args array to reveal how many parameters were actually passed. So I'm not sure if that level of abstraction would be useful... It may be taking it too far. We also lose some semantic naming to have one function name handle all of our variadic functions. Perhap, though, the benefit can be found in using it more like a factory function that produces other variadic functions each with their own helpful names:</p>
<pre><code class="language-js">// simpleLog, priorityLog &amp; serverLog are defined as above
const arityMap = [simpleLog, priorityLog, serverLog];
const polyLog = (msg, priority, dest) =&gt;
  variadic(arityMap, msg, priority, dest);
// anotherArityMap is not defined, but you can imagine what it might be
const anotherArityMap = [double, exponentiate, multiply];
const polyMath = (num1, num2, num3) =&gt;
  variadic(anotherArityMap, num1, num2, num3);
</code></pre>
<p>So this extra abstraction might be useful as a sort of variadic function factory, but your mileage may vary.</p>
<h2>Error Handling</h2>
<p>So far we've used <code>polyLog</code> under the &quot;Happy Path&quot; scenarios only. So let's think about the &quot;Sad Path&quot; and error handling a bit. Sometimes <code>polyLog</code> might be called with no parameters or maybe even with more than three parameters. Let's add some more structure to the function-arity map array so that it can safely handle such situations:</p>
<pre><code class="language-js">// The sub-functions are back in an internal array in this example
function polyLog(msg, priority, dest) {
  const nargs = arguments.length;
  return [
    () =&gt; console.log(&quot;Error: polyLog was invoked with no arguments&quot;),
    () =&gt; console.log(msg),
    () =&gt; console.log(`[${priority}] ${msg}`),
    () =&gt; dest.log(`[${priority}] ${msg}`),
    () =&gt;
      console.log(
        &quot;Error: polyLog was invoked with too many arguments: &quot; + nargs
      ),
  ][nargs &gt; 3 ? 4 : nargs]();
}
</code></pre>
<p>We've changed how we are accessing the array index now to use the value of <code>arguments.length</code> without substracting <code>1</code> because now we've added a new sub-function that will execute when no parameters are passed. We also save a reference to <code>arguments.length</code> in the constant <code>nargs</code> (number of args) since we now access that value twice. Finally, we perform a quick comparison on <code>nargs</code> to catch the scenario where more than 3 parameters are passed. In such a case we pass a value of 4 so that a default function will be invoked for handling such errors. The sub-functions at positions 0 and 4 can be customized to handle those class of errors in the way best suited for your use case.</p>
<p>If you absolutely want to remove the harded coded numbers <code>3</code> &amp; <code>4</code>, then there's a change you can make to do so which uses the functions <code>.length</code> property, which references the number of parameters that are in the function definition. So we can define a <code>const len</code> that takes that value and uses that to compare against the number of parameters that were actually passed in <code>nargs</code>.</p>
<pre><code class="language-js">function polyLog(msg, priority, dest) {
  const nargs = arguments.length;
  const len = polyLog.length;
  return [
    () =&gt; console.log(&quot;Error: polyLog was invoked with no arguments&quot;),
    () =&gt; console.log(msg),
    () =&gt; console.log(`[${priority}] ${msg}`),
    () =&gt; dest.log(`[${priority}] ${msg}`),
    () =&gt;
      console.log(
        &quot;Error: polyLog was invoked with too many arguments: &quot; + nargs
      ),
  ][nargs &gt; len ? len + 1 : nargs]();
}
</code></pre>
<h2>Typescript</h2>
<p>In Typescript we can extend this to get terse type checking as well:</p>
<pre><code class="language-ts">interface ServerpolyLog {
    log: (msg: string): void
}

function polyLog (
    msg: String,
    priority: Number | undefined,
    dest: ServerpolyLog | undefined
  ): void {
	return [
        () =&gt; console.log(msg),
        () =&gt; console.log(`[${priority}] ${msg}`),
        () =&gt; dest.log(`[${priority}] ${msg}`),
    ][arguments.length - 1]()
}
</code></pre>
<p>I'll leave it to the reader to incorporate the error handling parts into the Tyepscript implementation.</p>
</div></div></article></div><div class="text-center text-2xl my-16 underline"><a href="/log/posts">Read Another!</a></div></main></div><footer class="relative bg-accent-1 border-t border-accent-2"><div class="container mx-auto px-5"><div class="py-12 flex flex-col lg:flex-row items-center"><h3 class="text-4xl lg:text-5xl font-bold tracking-tighter leading-tight text-center lg:text-left mb-10 lg:mb-0 lg:pr-4 lg:w-1/2">Make üèóÔ∏è Devs</h3><div class="flex flex-col lg:flex-row justify-end items-center lg:pl-4 lg:w-1/2"><a href="https://wjv.io" class="mx-3 bg-black hover:bg-white hover:text-black border border-black text-white font-bold py-2 px-8 lg:px-8 duration-200 transition-colors mb-6 lg:mb-0">Portfolio</a><a href="https://github.com/JamieVaughn/log" class="mx-3 font-bold hover:underline">View on GitHub</a></div></div></div><span class="absolute bottom-1 right-2 text-xs">graphics from <span class="underline"><a href="https://designs.ai/graphicmaker">designs.ai</a></span></span></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"tags":["Functional","JavaScript","TypeScript"],"title":"Variadic Functions in Javascript","date":"2021-01-22T05:35:07.322Z","slug":"arity_polymorphism","author":{"name":"Jamie Vaughn","picture":"/authors/jj.jpeg"},"content":"\u003cp\u003eA Variadic Function describes a function that executes different logic depending on the arity, or the number of parameters passed to it. It is also called called function-overloading sometimes, mostly by detractors of this pattern. But this is a feature in many languages, especially functional paradigm languages. Languages like Elixir, Scheme and even Python support it.\u003c/p\u003e\n\u003cp\u003eWhile Javascript does not have this as a first-class capability, I'll demonstrate how to work within Javascript's constraints to create a variadic function.\u003c/p\u003e\n\u003ch2\u003eExample Use Case\u003c/h2\u003e\n\u003cp\u003eLet's imagine we want to implement a function that logs client-side events for us in a few different ways. We want it to be able to log a simple message or a message with a priority rating or log to our server using a service, depending on how many arguments are provided. One option is to define three different functions to accomplish this and call each one separately as the case may necessitate it. While there isn't anything necessarily wrong with that, it does present a non-consistent API surface with which to work with. What if we want to call just one logging function no matter which scenario, and let the function handle which internal logging logic to execute? And furthermore we want to do it in a way that avoids the cyclomatic complexity of \u003ccode\u003eif\u003c/code\u003e-\u003ccode\u003eelse\u003c/code\u003e statements...\u003c/p\u003e\n\u003cp\u003eWe could create such a function by leveraging Javascript's array data structure and map the the number of arguments passed to the function to an array position, which would hold the executable logic appropriate for that arity. The array is accessed by arity (minus one) and invoked and then it is returned. Let's take a look at what such a variadic function (we'll call it \u003ccode\u003epolyLog\u003c/code\u003e) might look like:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003e// We have some library/service that logs to a server via API call\nconst serverObj = {\n  log: (msg) =\u0026gt; Server.log(msg + \u0026quot; ...Logged to Server API.\u0026quot;),\n};\n\n// here is our variadic function\nfunction polyLog(msg, priority, dest) {\n  return [\n    () =\u0026gt; console.log(msg),\n    () =\u0026gt; console.log(`[${priority}] ${msg}`),\n    () =\u0026gt; dest.log(`[${priority}] ${msg}`),\n  ][arguments.length - 1]();\n}\n\n// you can call it 3 ways for 3 different results\npolyLog(\u0026quot;msg\u0026quot;);\npolyLog(\u0026quot;msg\u0026quot;, 5);\npolyLog(\u0026quot;msg\u0026quot;, 5, serverObj);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSo you can see we've leveraged a Javascript array and the fact that the number of parameters passed to a function is exposed via the \u003ccode\u003earguments\u003c/code\u003e keyword within the function body. The appropriate index of the array is accessed with \u003ccode\u003earguments.length - 1\u003c/code\u003e so the array evaluates to the associated sub-function. The order of the sub-functions in the array must be carefully chosen to correspond with the arguments they need. That part is up the developer to ensure.\u003c/p\u003e\n\u003cp\u003eEncapsulating all of this logging functionality inside one function not only conveniently reduces the API surface for us, but it just makes more sense since it is all related behavior. It also improves maintainability by keeping the function definitions of all possible logging behavior co-located in one data structure. And during refactors, one fix ought to automatically propogate to all invocations of \u003ccode\u003epolyLog\u003c/code\u003e within the app.\u003c/p\u003e\n\u003ch2\u003eSome Refactoring\u003c/h2\u003e\n\u003cp\u003eThe previous section describes the crux of the idea and accomplishes our goal of a variadic, but let's see if we can clean up or improve that code at all.\u003c/p\u003e\n\u003cp\u003eThe first refactoring opportunity is to use function expressions instead of defining the functions inside the returned array. So lets define our logging functions above our \u003ccode\u003epolyLog\u003c/code\u003e function like so:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003econst simpleLog = (msg) =\u0026gt; console.log(msg);\nconst priorityLog = (msg, priority) =\u0026gt; console.log(`[${priority}] ${msg}`);\nconst serverLog = (msg, priority, dest) =\u0026gt; dest.log(`[${priority}] ${msg}`);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou'll notice one other necessary change to the sub-functions: We are passing the parameters through now, since they won't be available from the parent scope anymore.\u003c/p\u003e\n\u003cp\u003eWe can also make a small memory optimization by defining our array of functions externally and referencing it in our variadic \u003ccode\u003epolyLog\u003c/code\u003e function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003e// this external array becomes our function-arity map\nconst arityMap = [simpleLog, priorityLog, serverLog];\n\n// Now polyLog is a wrapping interface for our function-arity map\nconst polyLog = function (msg, priority, dest) {\n  return arityMap[arguments.length - 1](msg, priority, dest);\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSo now the array of sub-functions is defined once instead of each time \u003ccode\u003epolyLog\u003c/code\u003e is invoked, which saves on memory. And our function is also mostly just an abstraction layer wrapping our array that serves as our function-arity map.\u003c/p\u003e\n\u003ch3\u003eNote On Arrow Functions\u003c/h3\u003e\n\u003cp\u003eIt's important to note, this technique doesn't really work with arrow functions as they do not contain a reference to \u003ccode\u003earguments\u003c/code\u003e in their function body. However, there is a hacky workaround by using the spread operator, although this should be avoided as the parameters necessarily will lose all or most of their semantic meaning.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003econst arityMap = [simpleLog, priorityLog, serverLog];\nconst polyLog = (...args) =\u0026gt; arityMap[args.length - 1](...args);\n// Because we spread on args, we don't know what each parameter is called anymore\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eMore Abstraction\u003c/h2\u003e\n\u003cp\u003eNow that \u003ccode\u003epolyLog\u003c/code\u003e has been abstracted in the \u0026quot;Some Refactoring\u0026quot; section, it is starting to look more like a general API surface. But let's try to abstract it further. What if we allow the function-arity array to be passed in as a parameter as well so that we can define one \u003ccode\u003evariadic\u003c/code\u003e function that could allow any array of functions be invoked with indefinite arity?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003efunction variadic(array, ...args) {\n  const arity = args.filter((a) =\u0026gt; a !== undefined).length;\n  return array[arity - 1](...args);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA trade-off that has to be made here is spreading the \u003ccode\u003eargs\u003c/code\u003e out because for this abstract case, we will not know how many parameters the functions will be needing. And so it suffers from not being able to make use of the \u003ccode\u003earguments\u003c/code\u003e keyword as before. Instead we have to filter the args array to reveal how many parameters were actually passed. So I'm not sure if that level of abstraction would be useful... It may be taking it too far. We also lose some semantic naming to have one function name handle all of our variadic functions. Perhap, though, the benefit can be found in using it more like a factory function that produces other variadic functions each with their own helpful names:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003e// simpleLog, priorityLog \u0026amp; serverLog are defined as above\nconst arityMap = [simpleLog, priorityLog, serverLog];\nconst polyLog = (msg, priority, dest) =\u0026gt;\n  variadic(arityMap, msg, priority, dest);\n// anotherArityMap is not defined, but you can imagine what it might be\nconst anotherArityMap = [double, exponentiate, multiply];\nconst polyMath = (num1, num2, num3) =\u0026gt;\n  variadic(anotherArityMap, num1, num2, num3);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSo this extra abstraction might be useful as a sort of variadic function factory, but your mileage may vary.\u003c/p\u003e\n\u003ch2\u003eError Handling\u003c/h2\u003e\n\u003cp\u003eSo far we've used \u003ccode\u003epolyLog\u003c/code\u003e under the \u0026quot;Happy Path\u0026quot; scenarios only. So let's think about the \u0026quot;Sad Path\u0026quot; and error handling a bit. Sometimes \u003ccode\u003epolyLog\u003c/code\u003e might be called with no parameters or maybe even with more than three parameters. Let's add some more structure to the function-arity map array so that it can safely handle such situations:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003e// The sub-functions are back in an internal array in this example\nfunction polyLog(msg, priority, dest) {\n  const nargs = arguments.length;\n  return [\n    () =\u0026gt; console.log(\u0026quot;Error: polyLog was invoked with no arguments\u0026quot;),\n    () =\u0026gt; console.log(msg),\n    () =\u0026gt; console.log(`[${priority}] ${msg}`),\n    () =\u0026gt; dest.log(`[${priority}] ${msg}`),\n    () =\u0026gt;\n      console.log(\n        \u0026quot;Error: polyLog was invoked with too many arguments: \u0026quot; + nargs\n      ),\n  ][nargs \u0026gt; 3 ? 4 : nargs]();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe've changed how we are accessing the array index now to use the value of \u003ccode\u003earguments.length\u003c/code\u003e without substracting \u003ccode\u003e1\u003c/code\u003e because now we've added a new sub-function that will execute when no parameters are passed. We also save a reference to \u003ccode\u003earguments.length\u003c/code\u003e in the constant \u003ccode\u003enargs\u003c/code\u003e (number of args) since we now access that value twice. Finally, we perform a quick comparison on \u003ccode\u003enargs\u003c/code\u003e to catch the scenario where more than 3 parameters are passed. In such a case we pass a value of 4 so that a default function will be invoked for handling such errors. The sub-functions at positions 0 and 4 can be customized to handle those class of errors in the way best suited for your use case.\u003c/p\u003e\n\u003cp\u003eIf you absolutely want to remove the harded coded numbers \u003ccode\u003e3\u003c/code\u003e \u0026amp; \u003ccode\u003e4\u003c/code\u003e, then there's a change you can make to do so which uses the functions \u003ccode\u003e.length\u003c/code\u003e property, which references the number of parameters that are in the function definition. So we can define a \u003ccode\u003econst len\u003c/code\u003e that takes that value and uses that to compare against the number of parameters that were actually passed in \u003ccode\u003enargs\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003efunction polyLog(msg, priority, dest) {\n  const nargs = arguments.length;\n  const len = polyLog.length;\n  return [\n    () =\u0026gt; console.log(\u0026quot;Error: polyLog was invoked with no arguments\u0026quot;),\n    () =\u0026gt; console.log(msg),\n    () =\u0026gt; console.log(`[${priority}] ${msg}`),\n    () =\u0026gt; dest.log(`[${priority}] ${msg}`),\n    () =\u0026gt;\n      console.log(\n        \u0026quot;Error: polyLog was invoked with too many arguments: \u0026quot; + nargs\n      ),\n  ][nargs \u0026gt; len ? len + 1 : nargs]();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eTypescript\u003c/h2\u003e\n\u003cp\u003eIn Typescript we can extend this to get terse type checking as well:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ts\"\u003einterface ServerpolyLog {\n    log: (msg: string): void\n}\n\nfunction polyLog (\n    msg: String,\n    priority: Number | undefined,\n    dest: ServerpolyLog | undefined\n  ): void {\n\treturn [\n        () =\u0026gt; console.log(msg),\n        () =\u0026gt; console.log(`[${priority}] ${msg}`),\n        () =\u0026gt; dest.log(`[${priority}] ${msg}`),\n    ][arguments.length - 1]()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eI'll leave it to the reader to incorporate the error handling parts into the Tyepscript implementation.\u003c/p\u003e\n","ogImage":{"url":"/img/cover.jpg"},"coverImage":"/img/cover.jpg"}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"arity_polymorphism"},"buildId":"pV2irWljyY_HBH9QdnYAB","assetPrefix":"/log","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>