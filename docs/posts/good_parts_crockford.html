<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png"/><link rel="manifest" href="/favicons/site.webmanifest"/><link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicons/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta name="description" content="Thoughts on our awesome collective web platform."/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>The Good and Bad Parts of JS (according to Douglas Crockford) | Make Devs</title><meta property="og:image" content="/img/cover.jpg"/><meta name="next-head-count" content="16"/><link rel="preload" href="/log/_next/static/css/a7c488a3d94a7e0a.css" as="style"/><link rel="stylesheet" href="/log/_next/static/css/a7c488a3d94a7e0a.css" data-n-g=""/><link rel="preload" href="/log/_next/static/css/cf121497002c184d.css" as="style"/><link rel="stylesheet" href="/log/_next/static/css/cf121497002c184d.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/log/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/log/_next/static/chunks/webpack-c6d930e7ce3de825.js" defer=""></script><script src="/log/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/log/_next/static/chunks/main-b58ac34e0b98c3ee.js" defer=""></script><script src="/log/_next/static/chunks/pages/_app-90e414d931afb8eb.js" defer=""></script><script src="/log/_next/static/chunks/893-bb16ac16a245221e.js" defer=""></script><script src="/log/_next/static/chunks/349-6549a57f16834f01.js" defer=""></script><script src="/log/_next/static/chunks/pages/posts/%5Bslug%5D-b92481cdf92bcf57.js" defer=""></script><script src="/log/_next/static/pV2irWljyY_HBH9QdnYAB/_buildManifest.js" defer=""></script><script src="/log/_next/static/pV2irWljyY_HBH9QdnYAB/_ssgManifest.js" defer=""></script><script src="/log/_next/static/pV2irWljyY_HBH9QdnYAB/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="min-h-screen"><main><div class="container mx-auto px-5"><h2 class="text-2xl md:text-4xl font-bold tracking-tight md:tracking-tighter leading-tight mb-20 mt-8"><a class="hover:underline" href="/log">Make üèóÔ∏è Devs</a></h2><article class="mb-32"><div class="-mb-36 md:-mb-36 sm:-mx-8"><div class="sm:mx-0"><img src="/log//img/cover.jpg" alt="Cover Image for The Good and Bad Parts of JS (according to Douglas Crockford)" class="responsive shadow-sm" width="310" height="160"/></div></div><h1 class="text-4xl md:text-5xl lg:text-6xl font-bold tracking-tighter leading-tight md:leading-none mb-12 text-center" style="transform:translateZ(0);background-image:radial-gradient(white 30%, transparent 50%)">The Good and Bad Parts of JS (according to Douglas Crockford)</h1><div class="mb-6 text-lg flex justify-around" style="transform:translateZ(0)"><time dateTime="2019-12-30T14:50:07.322Z">December	30, 2019</time><div class="flex items-center"><img src="/log//authors/jj.jpeg" class="w-12 h-12 rounded-full mr-4" alt="Jamie Vaughn"/><div class="text-xl font-bold">Jamie Vaughn</div></div></div><div class="max-w-2xl mx-auto"><div class="markdown-styles_markdown__h_8de"><p>Javascript, having famously been created in ten days, has some weird parts. Some of the baggage is from being around for so long and from being a creation of the ECMAScript TC39 committee. Despite all of that, it is still a great language with a lot of power and expressiveness. Douglas Crockford contends the detractors of Javascript mainly get frustrated with the language because they approach it from an Object Oriented angle instead of a Functional angle (it is based on Scheme after all, a 1970's FP language). This is by no means exhaustive, but here are some notes on What Crockford considers good (and bad) about JS:</p>
<h2>The Good Parts</h2>
<h3>First Class Functions or Higher Order Functions</h3>
<p>Functions in JS can take functions as parameters and return functions as values. Javascript has always had this (that's why I list it separately), as it was an adopted feature from Scheme. This permits powerful Currying, Closure patterns and the Continuation Passing Style.</p>
<h3>Good Parts from ES6+</h3>
<ol>
<li>Proper Tail Calls for Recursive Function optimization</li>
</ol>
<pre><code class="language-js">// The bad way:
function repeat(func) {
  while (func() !== undefined) {
    repeat(func);
  }
}
// Proper Tail Call way:
function repeat(func) {
  if (func() !== undefined) {
    return repeat(func);
  }
}
</code></pre>
<p>The second example enjoys a performance boost by using less memory due to the Tail call. Proper Tail Calls (i.e. tail call optimization) is simply when the last line of your function returns the self-invoked function. The optimization is from the stack frame to remove old function stack traces and replace it with the newly invoked trace, so there isn't a memory overflow threat.</p>
<ol start="2">
<li>The Spread and Rest Operator <code>[...array]</code></li>
<li>The Module System</li>
<li><code>let</code> and <code>const</code></li>
<li>Destructuring allows for easy RORO (receive object, return object) design patterns</li>
<li>Improved Object looping: <code>Object.keys.forEach()</code></li>
<li>WeakMap(): Works how Objects should have worked from the start with auto-garbage collection.</li>
<li>Template String Literals (great for templating and breaking up regex)</li>
</ol>
<pre><code class="language-js">`Hello ${name}`;
</code></pre>
<ol start="9">
<li>Arrow Functions (aka Lambdas): Great as callbacks/predicates</li>
<li>The suitability towards the Functional programming style</li>
</ol>
<pre><code class="language-js">// The JS way to do class-free OOP using Functions:
function constructor(spec) {
  let { member } = spec,
    { other } = other_constructor(spec),
    method = function () {
      /* member, other, method, spec */
    };
  return Object.freeze({
    method,
    other,
  });
}
</code></pre>
<h2>The Bad Parts</h2>
<h3>The Old</h3>
<ol>
<li>The <code>new</code> keyword (error-prone, prefer the literal syntax)</li>
<li>Object.create (prefer literal syntax or Object.assign({}, source) to avoid pass by reference errors)</li>
<li>The <code>this</code> keyword (error prone due to unintuitive value adoption)</li>
<li>label breaks</li>
<li>prototypes, prototypal inheritance (error prone due to confusion from Own vs. Inherited properties)
<blockquote>
<p>Note from the author: I disagree with Crockford on this point, I found prototypal inheritance to be much more intuitive than classical inheritance</p>
</blockquote>
</li>
<li><code>null</code> (There should only be <code>undefined</code> or <code>null</code>, not both. Since <code>null</code> regrettably returns typeof as <code>object</code>, it ought to be the one removed)</li>
<li>falsiness (Coercion in general due to unexpected values, but falsiness in particular trips up control flow quite often with values like <code>''</code> and <code>0</code>)</li>
<li><code>for</code> loops and <code>for...in</code> loops (prefer the `.forEach() syntax)</li>
<li><code>while</code> loops (prefer recursive functions with tail calls)</li>
</ol>
<h3>Bad Parts from ES6+</h3>
<h4>Classes</h4>
<p>This is only syntactic sugar over functions anyways and it does not change the prototypal inheritance model to the classical inheritance model, so it threatens to mislead OOP programmers about how properties are truly being inherited.</p>
<h4>Generators</h4>
<p>Crockford does not like these because he claims they are inherently &quot;stateful&quot; and cannot be pure functions (i.e. functions without side effects). Crockford feels that unaccounted for &quot;statefulness&quot; accounts for a large number of bugs/errors and so he prefers using pure functions whenever possible, and so dismisses generators since they are inherently impure.</p>
<blockquote>
<p>Note from the author: I somewhat disagree with Crockford's thoughts on this one: While generators <em>CAN</em> be stateful, they certainly do not have to be. It depends on how you author it. I do agree that generators cannot really be pure functions, but that is ok since they can serve as wrappers to other pure functions, which provide a nice Iterable interface for those pure functions. And having the control of an Iterator by default is a powerful interface for dealing with returned values.</p>
</blockquote>
<p>Overall I feel that I am in agreement with Crockford's opinions about which parts of Javascript to lean on and which parts to avoid. In particular, Javascript's origins from the Scheme language mean it is best used in the functional styleso it can take advantage of higher order functions, currying, closures, and recursion. And in general I agree about avoiding OOP patterns. Although, there is no need for fanatical avoidance of OOP, both FP and OOP can be used together to great effect.</p>
<p>I mentioned the two places already where I disgree with Crockford on his thoughts here: Prototypes and Generators. I think both of these language features actually have tremendous strengths. This is largely due to lessons I've absorbed from another great JS teacher, Kyle Simpson. I will have a similar notes-dump post about <em>his</em> thoughts in the future.</p>
</div></div></article></div><div class="text-center text-2xl my-16 underline"><a href="/log/posts">Read Another!</a></div></main></div><footer class="relative bg-accent-1 border-t border-accent-2"><div class="container mx-auto px-5"><div class="py-12 flex flex-col lg:flex-row items-center"><h3 class="text-4xl lg:text-5xl font-bold tracking-tighter leading-tight text-center lg:text-left mb-10 lg:mb-0 lg:pr-4 lg:w-1/2">Make üèóÔ∏è Devs</h3><div class="flex flex-col lg:flex-row justify-end items-center lg:pl-4 lg:w-1/2"><a href="https://wjv.io" class="mx-3 bg-black hover:bg-white hover:text-black border border-black text-white font-bold py-2 px-8 lg:px-8 duration-200 transition-colors mb-6 lg:mb-0">Portfolio</a><a href="https://github.com/JamieVaughn/log" class="mx-3 font-bold hover:underline">View on GitHub</a></div></div></div><span class="absolute bottom-1 right-2 text-xs">graphics from <span class="underline"><a href="https://designs.ai/graphicmaker">designs.ai</a></span></span></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"tags":["Javascript"],"title":"The Good and Bad Parts of JS (according to Douglas Crockford)","date":"2019-12-30T14:50:07.322Z","slug":"good_parts_crockford","author":{"name":"Jamie Vaughn","picture":"/authors/jj.jpeg"},"content":"\u003cp\u003eJavascript, having famously been created in ten days, has some weird parts. Some of the baggage is from being around for so long and from being a creation of the ECMAScript TC39 committee. Despite all of that, it is still a great language with a lot of power and expressiveness. Douglas Crockford contends the detractors of Javascript mainly get frustrated with the language because they approach it from an Object Oriented angle instead of a Functional angle (it is based on Scheme after all, a 1970's FP language). This is by no means exhaustive, but here are some notes on What Crockford considers good (and bad) about JS:\u003c/p\u003e\n\u003ch2\u003eThe Good Parts\u003c/h2\u003e\n\u003ch3\u003eFirst Class Functions or Higher Order Functions\u003c/h3\u003e\n\u003cp\u003eFunctions in JS can take functions as parameters and return functions as values. Javascript has always had this (that's why I list it separately), as it was an adopted feature from Scheme. This permits powerful Currying, Closure patterns and the Continuation Passing Style.\u003c/p\u003e\n\u003ch3\u003eGood Parts from ES6+\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003eProper Tail Calls for Recursive Function optimization\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003e// The bad way:\nfunction repeat(func) {\n  while (func() !== undefined) {\n    repeat(func);\n  }\n}\n// Proper Tail Call way:\nfunction repeat(func) {\n  if (func() !== undefined) {\n    return repeat(func);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe second example enjoys a performance boost by using less memory due to the Tail call. Proper Tail Calls (i.e. tail call optimization) is simply when the last line of your function returns the self-invoked function. The optimization is from the stack frame to remove old function stack traces and replace it with the newly invoked trace, so there isn't a memory overflow threat.\u003c/p\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003eThe Spread and Rest Operator \u003ccode\u003e[...array]\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eThe Module System\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elet\u003c/code\u003e and \u003ccode\u003econst\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eDestructuring allows for easy RORO (receive object, return object) design patterns\u003c/li\u003e\n\u003cli\u003eImproved Object looping: \u003ccode\u003eObject.keys.forEach()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eWeakMap(): Works how Objects should have worked from the start with auto-garbage collection.\u003c/li\u003e\n\u003cli\u003eTemplate String Literals (great for templating and breaking up regex)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003e`Hello ${name}`;\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"9\"\u003e\n\u003cli\u003eArrow Functions (aka Lambdas): Great as callbacks/predicates\u003c/li\u003e\n\u003cli\u003eThe suitability towards the Functional programming style\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003e// The JS way to do class-free OOP using Functions:\nfunction constructor(spec) {\n  let { member } = spec,\n    { other } = other_constructor(spec),\n    method = function () {\n      /* member, other, method, spec */\n    };\n  return Object.freeze({\n    method,\n    other,\n  });\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eThe Bad Parts\u003c/h2\u003e\n\u003ch3\u003eThe Old\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003eThe \u003ccode\u003enew\u003c/code\u003e keyword (error-prone, prefer the literal syntax)\u003c/li\u003e\n\u003cli\u003eObject.create (prefer literal syntax or Object.assign({}, source) to avoid pass by reference errors)\u003c/li\u003e\n\u003cli\u003eThe \u003ccode\u003ethis\u003c/code\u003e keyword (error prone due to unintuitive value adoption)\u003c/li\u003e\n\u003cli\u003elabel breaks\u003c/li\u003e\n\u003cli\u003eprototypes, prototypal inheritance (error prone due to confusion from Own vs. Inherited properties)\n\u003cblockquote\u003e\n\u003cp\u003eNote from the author: I disagree with Crockford on this point, I found prototypal inheritance to be much more intuitive than classical inheritance\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003enull\u003c/code\u003e (There should only be \u003ccode\u003eundefined\u003c/code\u003e or \u003ccode\u003enull\u003c/code\u003e, not both. Since \u003ccode\u003enull\u003c/code\u003e regrettably returns typeof as \u003ccode\u003eobject\u003c/code\u003e, it ought to be the one removed)\u003c/li\u003e\n\u003cli\u003efalsiness (Coercion in general due to unexpected values, but falsiness in particular trips up control flow quite often with values like \u003ccode\u003e''\u003c/code\u003e and \u003ccode\u003e0\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efor\u003c/code\u003e loops and \u003ccode\u003efor...in\u003c/code\u003e loops (prefer the `.forEach() syntax)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ewhile\u003c/code\u003e loops (prefer recursive functions with tail calls)\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003eBad Parts from ES6+\u003c/h3\u003e\n\u003ch4\u003eClasses\u003c/h4\u003e\n\u003cp\u003eThis is only syntactic sugar over functions anyways and it does not change the prototypal inheritance model to the classical inheritance model, so it threatens to mislead OOP programmers about how properties are truly being inherited.\u003c/p\u003e\n\u003ch4\u003eGenerators\u003c/h4\u003e\n\u003cp\u003eCrockford does not like these because he claims they are inherently \u0026quot;stateful\u0026quot; and cannot be pure functions (i.e. functions without side effects). Crockford feels that unaccounted for \u0026quot;statefulness\u0026quot; accounts for a large number of bugs/errors and so he prefers using pure functions whenever possible, and so dismisses generators since they are inherently impure.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eNote from the author: I somewhat disagree with Crockford's thoughts on this one: While generators \u003cem\u003eCAN\u003c/em\u003e be stateful, they certainly do not have to be. It depends on how you author it. I do agree that generators cannot really be pure functions, but that is ok since they can serve as wrappers to other pure functions, which provide a nice Iterable interface for those pure functions. And having the control of an Iterator by default is a powerful interface for dealing with returned values.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eOverall I feel that I am in agreement with Crockford's opinions about which parts of Javascript to lean on and which parts to avoid. In particular, Javascript's origins from the Scheme language mean it is best used in the functional styleso it can take advantage of higher order functions, currying, closures, and recursion. And in general I agree about avoiding OOP patterns. Although, there is no need for fanatical avoidance of OOP, both FP and OOP can be used together to great effect.\u003c/p\u003e\n\u003cp\u003eI mentioned the two places already where I disgree with Crockford on his thoughts here: Prototypes and Generators. I think both of these language features actually have tremendous strengths. This is largely due to lessons I've absorbed from another great JS teacher, Kyle Simpson. I will have a similar notes-dump post about \u003cem\u003ehis\u003c/em\u003e thoughts in the future.\u003c/p\u003e\n","ogImage":{"url":"/img/cover.jpg"},"coverImage":"/img/cover.jpg"}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"good_parts_crockford"},"buildId":"pV2irWljyY_HBH9QdnYAB","assetPrefix":"/log","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>