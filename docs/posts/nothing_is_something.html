<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png"/><link rel="manifest" href="/favicons/site.webmanifest"/><link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicons/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta name="description" content="Thoughts on our awesome collective web platform."/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>Composition over Inheritance and Revisiting the Null Object Pattern | Make Devs</title><meta property="og:image" content="/img/cover.jpg"/><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/9cc228776be9975c.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9cc228776be9975c.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cf121497002c184d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cf121497002c184d.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-9b312e20a4e32339.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-83803dd478f5b5bc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-90e414d931afb8eb.js" defer=""></script><script src="/_next/static/chunks/893-bb16ac16a245221e.js" defer=""></script><script src="/_next/static/chunks/349-6549a57f16834f01.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-526ce38baf3fe719.js" defer=""></script><script src="/_next/static/oc3N0y__jbrQdJAhe2PJR/_buildManifest.js" defer=""></script><script src="/_next/static/oc3N0y__jbrQdJAhe2PJR/_ssgManifest.js" defer=""></script><script src="/_next/static/oc3N0y__jbrQdJAhe2PJR/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="min-h-screen"><main><div class="container mx-auto px-5"><h2 class="text-2xl md:text-4xl font-bold tracking-tight md:tracking-tighter leading-tight mb-20 mt-8"><a class="hover:underline" href="/">Make üèóÔ∏è Devs</a></h2><article class="mb-32"><div class="-mb-36 md:-mb-36 sm:-mx-8"><div class="sm:mx-0"><img src="/img/cover.jpg" alt="Cover Image for Composition over Inheritance and Revisiting the Null Object Pattern" class="responsive shadow-sm" width="310" height="160"/></div></div><h1 class="text-4xl md:text-5xl lg:text-6xl font-bold tracking-tighter leading-tight md:leading-none mb-12 text-center" style="transform:translateZ(0);background-image:radial-gradient(white 30%, transparent 50%)">Composition over Inheritance and Revisiting the Null Object Pattern</h1><div class="mb-6 text-lg flex justify-around" style="transform:translateZ(0)"><time dateTime="2021-01-18T05:25:07.322Z">January	18, 2021</time><div class="flex items-center"><img src="/authors/jj.jpeg" class="w-12 h-12 rounded-full mr-4" alt="Jamie Vaughn"/><div class="text-xl font-bold">Jamie Vaughn</div></div></div><div class="max-w-2xl mx-auto"><div class="markdown-styles_markdown__h_8de"><p>Sandi Metz delivered a fantastic <a href="https://www.youtube.com/watch?v=OMPfEXIlTVE">conference talk</a> about Composition called &quot;Nothing is Something.&quot; This article is a summary of what I learned from this talk.</p>
<h2>Favor Composition Over Inheritance</h2>
<p>Inheritance is for specialization, which is needed far less than one might assume. Composition provides a way to create units of pluggable behavior. While inheritance sets out to make code reusable, it actually often leads to code duplication if used for things it is not intended. And there are very few instances where inheritance is actually the correct tool for the job. Composiiton ends up being a better tool for the job more often. It lets us avoid code duplication and couple two or more behaviors together in any permutation without code duplication.</p>
<p>Inheritance often fails to provide a similar behavior because if any inherited method is not needed by the child or needs to be overwritten for the child's use case, then the benefit of the inheritance is lost. In order to to ensure that there are never unnecessary properties or methods inherited by the child, one could reduce parent classes down to a single property or method. But this either requires multiple inheritance (which not all languages support) or requires writing extra code in the child that is not represented in the parent you chose to inherit from. That extra code may even be in another class, that is simply unable to shared now because of the constraints of inheritance.</p>
<p>Composition uses functions that can be passed and invoked anywhere without the constraints of inheriting classes. This means that functions can essentially be used like multiple inheritance would be by default.</p>
<h2>Finding the Composable Algorithm</h2>
<p>Composition can be tricky at first because some behaviors are not obviously expressed as an algorithm at first glance. But when you have the urge to use inheritance because you think the new thing needs to specialize, then most of the time, the thing you are specializing on is simply a different behavior of what the parent object behavior is. So that's a clue that maybe Composition can be used there. The parent object behavior is still an algorithm, it just needs to be extracted out into the form of a function. Sometimes the algorithm (in the FP paradigm: a callback) is one that does nothing, but that is still something: it is a no-op function... a function that is just returning some chunk of unmodified state or some type of empty value.</p>
<p>Here are a set of steps to help you identify the role/behavior that is at work:</p>
<ol>
<li>Figure out what is varying (what are the algorithms of each behavior actually doing, even if it is &quot;nothing&quot;)</li>
<li>Name that role, behavior or trait (i.e. 'order', 'repeatNTimes', 'format', 'randomize')</li>
<li>Define that role (make API's for it that can be plugged into anywhere)</li>
<li>Inject the executor</li>
</ol>
<blockquote>
<p>Order is not a House, Order is a role.</p>
</blockquote>
<p><strong>Sandi Metz</strong></p>
<p><img src="/img/composition.png" alt="Nothing is Something!" /></p>
<p>In the example in the talk from which the above table is reprinted, there is a different sorting algorithm for the phrases in the House Class. Instead of inheriting different orders of the phrases, simply instantiate the phrase and inject different sorting algorithms to re-order the phrases. For the House that needs the phrases in the starting order, simply inject a no-op function as the sorting algorithm: thus &quot;Nothing is Something&quot;... a No-op function is the Algorithm needed for that case.</p>
<h2>OOP</h2>
<p>Inheritance is often presented as an essential part of Object Oriented Programming. But this talk claims that Composition paired with Dependency Injection is also Object Oriented Design. Object Oriented Composition is injecting an object (or function) with a behavior (algorithm) to play the role of the thing that you want to vary. This is a more flexible and less error-prone compared to inheriting the algorithm you want to vary.</p>
<p>The Composition and behavior injection approach is actually more true to what Alan Kay meant when he coined the term &quot;Object Oriented Programming.&quot;</p>
<blockquote>
<p>OOP to me means only messaging, local retention and protection and hiding of state-process, and extreme late-binding of all things.</p>
</blockquote>
<blockquote>
<p>...the very first problems I solved with my early Utah stuff was the &quot;disappearing of data&quot; using only methods and objects. At the end of the 60s (I think) Bob Balzer wrote a pretty nifty paper called &quot;Dataless Programming&quot;, and shortly thereafter John Reynolds wrote an equally nifty paper &quot;Gedanken&quot; (in 1970 I think) in which he showed that using the lamda expressions the right way would allow data to be abstracted by procedures.</p>
</blockquote>
<blockquote>
<p>The people who liked objects as non-data were smaller in number, and included myself, Carl Hewitt, Dave Reed and a few others -- pretty much all of this group were from the ARPA community and were involved in one way or another with the design of ARPAnet ‚Üí Internet in which the basic unit of computation was a whole computer.</p>
</blockquote>
<p>...</p>
<blockquote>
<p>I was too blythe about the term back in the 60s and should have chosen something like &quot;message oriented&quot;</p>
</blockquote>
<p><strong>Alan Kay</strong> (<a href="https://softwareengineering.stackexchange.com/questions/46592/so-what-did-alan-kay-really-mean-by-the-term-object-oriented">source</a>)</p>
<p>What he meant was something actually a bit closer to Functional Programming it seems, where messages are passed between objects to trigger behaviors. And Composition extends this to pass around algorithms as messages for the objects to execute as their behaviors.</p>
<h2>Final Take Aways</h2>
<p>The Composition strategy is especially helpful with the Null Object Pattern. It can potentially allow us to stop checking for and handling <code>null</code> in all our functions. Instead, we can use an object to stand in for <code>null</code> and use those &quot;active nothings.&quot;</p>
<p>Beware of inheritance. Inheritance is NOT for sharing behaviors. It's for specialization.
There is no such thing as ONE specialization. Define the role instead
Remember that Nothing is Something. In every program there are things that manifest as the absence of an algorithm or code, so represent it by the thing that manifests nothing: the no-op function. The no-op is analagous to the Zero in the number system, and just as important because it keeps the object messaging API surface consistent even for otherwise inconsistent behaviors.</p>
</div></div></article></div><div class="text-center text-2xl my-16 underline"><a href="/posts">Read Another!</a></div></main></div><footer class="relative bg-accent-1 border-t border-accent-2"><div class="container mx-auto px-5"><div class="py-12 flex flex-col lg:flex-row items-center"><h3 class="text-4xl lg:text-5xl font-bold tracking-tighter leading-tight text-center lg:text-left mb-10 lg:mb-0 lg:pr-4 lg:w-1/2">Make üèóÔ∏è Devs</h3><div class="flex flex-col lg:flex-row justify-end items-center lg:pl-4 lg:w-1/2"><a href="https://wjv.io" class="mx-3 bg-black hover:bg-white hover:text-black border border-black text-white font-bold py-2 px-8 lg:px-8 duration-200 transition-colors mb-6 lg:mb-0">Portfolio</a><a href="https://github.com/JamieVaughn/log" class="mx-3 font-bold hover:underline">View on GitHub</a></div></div></div><span class="absolute bottom-1 right-2">graphics from <span class="underline"><a href="https://designs.ai/graphicmaker">designs.ai</a></span></span></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Composition over Inheritance and Revisiting the Null Object Pattern","date":"2021-01-18T05:25:07.322Z","slug":"nothing_is_something","author":{"name":"Jamie Vaughn","picture":"/authors/jj.jpeg"},"content":"\u003cp\u003eSandi Metz delivered a fantastic \u003ca href=\"https://www.youtube.com/watch?v=OMPfEXIlTVE\"\u003econference talk\u003c/a\u003e about Composition called \u0026quot;Nothing is Something.\u0026quot; This article is a summary of what I learned from this talk.\u003c/p\u003e\n\u003ch2\u003eFavor Composition Over Inheritance\u003c/h2\u003e\n\u003cp\u003eInheritance is for specialization, which is needed far less than one might assume. Composition provides a way to create units of pluggable behavior. While inheritance sets out to make code reusable, it actually often leads to code duplication if used for things it is not intended. And there are very few instances where inheritance is actually the correct tool for the job. Composiiton ends up being a better tool for the job more often. It lets us avoid code duplication and couple two or more behaviors together in any permutation without code duplication.\u003c/p\u003e\n\u003cp\u003eInheritance often fails to provide a similar behavior because if any inherited method is not needed by the child or needs to be overwritten for the child's use case, then the benefit of the inheritance is lost. In order to to ensure that there are never unnecessary properties or methods inherited by the child, one could reduce parent classes down to a single property or method. But this either requires multiple inheritance (which not all languages support) or requires writing extra code in the child that is not represented in the parent you chose to inherit from. That extra code may even be in another class, that is simply unable to shared now because of the constraints of inheritance.\u003c/p\u003e\n\u003cp\u003eComposition uses functions that can be passed and invoked anywhere without the constraints of inheriting classes. This means that functions can essentially be used like multiple inheritance would be by default.\u003c/p\u003e\n\u003ch2\u003eFinding the Composable Algorithm\u003c/h2\u003e\n\u003cp\u003eComposition can be tricky at first because some behaviors are not obviously expressed as an algorithm at first glance. But when you have the urge to use inheritance because you think the new thing needs to specialize, then most of the time, the thing you are specializing on is simply a different behavior of what the parent object behavior is. So that's a clue that maybe Composition can be used there. The parent object behavior is still an algorithm, it just needs to be extracted out into the form of a function. Sometimes the algorithm (in the FP paradigm: a callback) is one that does nothing, but that is still something: it is a no-op function... a function that is just returning some chunk of unmodified state or some type of empty value.\u003c/p\u003e\n\u003cp\u003eHere are a set of steps to help you identify the role/behavior that is at work:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eFigure out what is varying (what are the algorithms of each behavior actually doing, even if it is \u0026quot;nothing\u0026quot;)\u003c/li\u003e\n\u003cli\u003eName that role, behavior or trait (i.e. 'order', 'repeatNTimes', 'format', 'randomize')\u003c/li\u003e\n\u003cli\u003eDefine that role (make API's for it that can be plugged into anywhere)\u003c/li\u003e\n\u003cli\u003eInject the executor\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003eOrder is not a House, Order is a role.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cstrong\u003eSandi Metz\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/composition.png\" alt=\"Nothing is Something!\" /\u003e\u003c/p\u003e\n\u003cp\u003eIn the example in the talk from which the above table is reprinted, there is a different sorting algorithm for the phrases in the House Class. Instead of inheriting different orders of the phrases, simply instantiate the phrase and inject different sorting algorithms to re-order the phrases. For the House that needs the phrases in the starting order, simply inject a no-op function as the sorting algorithm: thus \u0026quot;Nothing is Something\u0026quot;... a No-op function is the Algorithm needed for that case.\u003c/p\u003e\n\u003ch2\u003eOOP\u003c/h2\u003e\n\u003cp\u003eInheritance is often presented as an essential part of Object Oriented Programming. But this talk claims that Composition paired with Dependency Injection is also Object Oriented Design. Object Oriented Composition is injecting an object (or function) with a behavior (algorithm) to play the role of the thing that you want to vary. This is a more flexible and less error-prone compared to inheriting the algorithm you want to vary.\u003c/p\u003e\n\u003cp\u003eThe Composition and behavior injection approach is actually more true to what Alan Kay meant when he coined the term \u0026quot;Object Oriented Programming.\u0026quot;\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eOOP to me means only messaging, local retention and protection and hiding of state-process, and extreme late-binding of all things.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e...the very first problems I solved with my early Utah stuff was the \u0026quot;disappearing of data\u0026quot; using only methods and objects. At the end of the 60s (I think) Bob Balzer wrote a pretty nifty paper called \u0026quot;Dataless Programming\u0026quot;, and shortly thereafter John Reynolds wrote an equally nifty paper \u0026quot;Gedanken\u0026quot; (in 1970 I think) in which he showed that using the lamda expressions the right way would allow data to be abstracted by procedures.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThe people who liked objects as non-data were smaller in number, and included myself, Carl Hewitt, Dave Reed and a few others -- pretty much all of this group were from the ARPA community and were involved in one way or another with the design of ARPAnet ‚Üí Internet in which the basic unit of computation was a whole computer.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e...\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eI was too blythe about the term back in the 60s and should have chosen something like \u0026quot;message oriented\u0026quot;\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cstrong\u003eAlan Kay\u003c/strong\u003e (\u003ca href=\"https://softwareengineering.stackexchange.com/questions/46592/so-what-did-alan-kay-really-mean-by-the-term-object-oriented\"\u003esource\u003c/a\u003e)\u003c/p\u003e\n\u003cp\u003eWhat he meant was something actually a bit closer to Functional Programming it seems, where messages are passed between objects to trigger behaviors. And Composition extends this to pass around algorithms as messages for the objects to execute as their behaviors.\u003c/p\u003e\n\u003ch2\u003eFinal Take Aways\u003c/h2\u003e\n\u003cp\u003eThe Composition strategy is especially helpful with the Null Object Pattern. It can potentially allow us to stop checking for and handling \u003ccode\u003enull\u003c/code\u003e in all our functions. Instead, we can use an object to stand in for \u003ccode\u003enull\u003c/code\u003e and use those \u0026quot;active nothings.\u0026quot;\u003c/p\u003e\n\u003cp\u003eBeware of inheritance. Inheritance is NOT for sharing behaviors. It's for specialization.\nThere is no such thing as ONE specialization. Define the role instead\nRemember that Nothing is Something. In every program there are things that manifest as the absence of an algorithm or code, so represent it by the thing that manifests nothing: the no-op function. The no-op is analagous to the Zero in the number system, and just as important because it keeps the object messaging API surface consistent even for otherwise inconsistent behaviors.\u003c/p\u003e\n","ogImage":{"url":"/img/cover.jpg"},"coverImage":"/img/cover.jpg"}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"nothing_is_something"},"buildId":"oc3N0y__jbrQdJAhe2PJR","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>