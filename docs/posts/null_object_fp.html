<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png"/><link rel="manifest" href="/favicons/site.webmanifest"/><link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicons/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta name="description" content="Thoughts on our awesome collective web platform."/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>The Null Object Pattern in the Functional Style | Make Devs</title><meta property="og:image" content="/img/cover.jpg"/><meta name="next-head-count" content="16"/><link rel="preload" href="/log/_next/static/css/f59bbd0257d21d45.css" as="style"/><link rel="stylesheet" href="/log/_next/static/css/f59bbd0257d21d45.css" data-n-g=""/><link rel="preload" href="/log/_next/static/css/cf121497002c184d.css" as="style"/><link rel="stylesheet" href="/log/_next/static/css/cf121497002c184d.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/log/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/log/_next/static/chunks/webpack-c6d930e7ce3de825.js" defer=""></script><script src="/log/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/log/_next/static/chunks/main-b58ac34e0b98c3ee.js" defer=""></script><script src="/log/_next/static/chunks/pages/_app-90e414d931afb8eb.js" defer=""></script><script src="/log/_next/static/chunks/893-bb16ac16a245221e.js" defer=""></script><script src="/log/_next/static/chunks/349-6549a57f16834f01.js" defer=""></script><script src="/log/_next/static/chunks/pages/posts/%5Bslug%5D-527e0d774f36b704.js" defer=""></script><script src="/log/_next/static/obrXrIdU6aRWSbL_OwLjq/_buildManifest.js" defer=""></script><script src="/log/_next/static/obrXrIdU6aRWSbL_OwLjq/_ssgManifest.js" defer=""></script><script src="/log/_next/static/obrXrIdU6aRWSbL_OwLjq/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="min-h-screen"><main><div class="undefined container mx-auto px-5"><h2 class="text-2xl md:text-4xl font-bold tracking-tight md:tracking-tighter leading-tight mb-20 mt-8"><a class="hover:underline" href="/log">Make üèóÔ∏è Devs</a></h2><article class="mb-32"><div class="-mb-36 md:-mb-36 sm:-mx-8"><div class="sm:mx-0"><img src="/log//img/cover.jpg" alt="Cover Image for The Null Object Pattern in the Functional Style" class="responsive shadow-sm" width="310" height="160"/></div></div><h1 class="text-4xl md:text-5xl lg:text-6xl font-bold tracking-tighter leading-tight md:leading-none mb-12 text-center" style="transform:translateZ(0);background-image:radial-gradient(white 30%, transparent 50%)">The Null Object Pattern in the Functional Style</h1><div class="mb-6 text-lg flex justify-around" style="transform:translateZ(0)"><time dateTime="2020-02-21T08:50:07.322Z">February	21, 2020</time><div class="flex items-center"><img src="/log//authors/jj.jpeg" class="w-12 h-12 rounded-full mr-4" alt="Jamie Vaughn"/><div class="text-xl font-bold">Jamie Vaughn</div></div></div><div class="max-w-2xl mx-auto"><div class="markdown-styles_markdown__h_8de"><p>The Null Object Pattern is a common way in OOP to handle <code>null</code> references in a graceful way. If a reference to an object is <code>null</code> and a method is invoked on that reference, then this will cause an error. Instead, a Null Object can be implemented with the same interface, but where the methods are no-op methods. Other objects can inherit from this Null Object in such a way, that if a <code>null</code> reference is passed then they will use the no-op methods from the Null Object rather than throwing an error.</p>
<p>Why not just use conditional checks using <code>if</code> statements to check for null? You certainly can. But in OOP it is prefered to use polymorphism over conditionals where possible. In FP, there isn't really an exact counterpart to polymorphism so replicating it takes some adaptation. But in both paradigms, the avoidance of conditionals and <code>if</code> statements is desired and can be achieved because the goal is to reduce branching in the program. The problem with handling <code>null</code> is that it necessarily adds branching to your logic, because you now have to handle another case. But the Null Object Pattern, while not completely removing it, can at least encapsulate and hide that branching for us.</p>
<h2>Typical OOP implementation in JS</h2>
<pre><code class="language-js">class Discount {
  calculateDiscount() {
    return 0.15;
  }
}
class NoDiscount {
  calculateDiscount() {
    return null;
  }
}
function getDiscount(orderType) {
  return orderType === &quot;matin√©e&quot; ? new Discount() : new NoDiscount();
}

[getDiscount(&quot;matin√©e&quot;), null].map((o) =&gt; getDiscount(o).calculateDiscount()); // [0.15, null]
</code></pre>
<p>Using the null object pattern, a special version of the Class is created that has the same method and signature, but it only handles <code>null</code> values and mitigates the need for more tedious control flow logic that checks for <code>null</code> values in the original class interface.</p>
<h2>Typical Functional implementation in JS</h2>
<p>Previously we saw a way to implement the Null Object Pattern in an OOP style. A functional style of handling it would look like this:</p>
<pre><code class="language-js">function Discounts(type) {
  let types = {
    regular: {
      calc() {
        return 0.15;
      },
    },
    nullDiscount: {
      calc() {
        return null;
      },
    },
  };
  return types[type] || types.nullDiscount;
}
Discounts(&quot;regular&quot;).calc(); // 0.15
Discounts(null).calc(); // null
</code></pre>
<h2>ECMAScript 2020: Is this pattern necessary anymore?</h2>
<p>In the latest version of ECMAScript there are a couple of operators that more or less obviate the need to implement a custom Null Object handler. They are called Optional Chaining (<code>?.</code>) and Nullish Coalescing (<code>??</code>).</p>
<p>Optional Chaining can be used when trying to access methods or properties on any object such that accessing an undefined property will not cause an error and instead it can be handled with minimal control flow. It would look like this:</p>
<pre><code class="language-js">class Discount {
  calc() {
    return 0.15;
  }
  days = &quot;MTWTF&quot;;
}
let special = new Discount();
special.calc?.(); // 0.15
special.order(); // Uncaught TypeError ü§¨
special.order?.(); // undefined (ok, that's better)
special.order?.() || &quot;No specials&quot;; // 'No specials' (NICE!)
special.day; // undefined anyways so optional chaining is not needed for properties
</code></pre>
<p>When we call the non-existent <code>order</code> method unsafely we get an uncaught type error ü§¨. We want to avoidthat at all costs. Optional chaining allows us to call <code>order</code> in a safe way which can be handled by error paths in the code relatively easily.</p>
<p>This works the same for JS objects:</p>
<pre><code class="language-js">let obj = {
  days: 'MWT',
  order: () =&gt; ['burger', 'fries']
  points: () =&gt; 0
}

obj.day // undefined already (it's a property, not a method)
obj.special() // Uncaught TypeError ü§¨
obj.special?.() // undefined
</code></pre>
<p>And we can combine this with Nullish Coallescing to get a fully operational Null Object Handling that also respects intentional falsey values. It's a one liner that can fit anywhere in our code when referencing potentially non-existent methods:</p>
<pre><code class="language-js">// using `obj` from previous code block
obj.special?.() ?? &quot;No Special&quot;; // 'No Special'
obj.points?.() || &quot;Could not fetch points&quot;; // 'Could not fetch points'
obj.points?.() ?? &quot;Could not fetch points&quot;; // 0
</code></pre>
<p>So we can see the Nullish Coalescer allows us to handle null and undefined methods alongside methods that may return falsy values like <code>0</code> or <code>''</code> or <code>false</code>.</p>
<p>So is optional chaining combined with nullish coalescing enough to recreate the Null Object pattern in JS? I think so, but perhaps others may still build something more robust like Maybe Monads or Null Object Handling Classes. But I'll be reaching for hese two new tools, optional chaing and nullish coallescing, in ECMAScript first in my programs before opting to go with the more complex patterns.</p>
</div></div></article></div><div class="text-center text-2xl my-16 underline"><a href="/log/posts">Read Another!</a></div></main></div><footer class="relative bg-accent-1 border-t border-accent-2"><div class="undefined container mx-auto px-5"><div class="py-12 flex flex-col lg:flex-row items-center"><h3 class="text-4xl lg:text-5xl font-bold tracking-tighter leading-tight text-center lg:text-left mb-10 lg:mb-0 lg:pr-4 lg:w-1/2">Make üèóÔ∏è Devs</h3><div class="flex flex-col lg:flex-row justify-end items-center lg:pl-4 lg:w-1/2"><a href="https://wjv.io" class="mx-3 bg-black hover:bg-white hover:text-black border border-black text-white font-bold py-2 px-8 lg:px-8 duration-200 transition-colors mb-6 lg:mb-0">Portfolio</a><a href="https://github.com/JamieVaughn/log" class="mx-3 font-bold hover:underline">View on GitHub</a></div></div></div><span class="absolute bottom-1 right-2 text-xs">graphics from <span class="underline"><a href="https://designs.ai/graphicmaker">designs.ai</a></span></span></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"tags":["Javascript","Functional"],"title":"The Null Object Pattern in the Functional Style","date":"2020-02-21T08:50:07.322Z","slug":"null_object_fp","author":{"name":"Jamie Vaughn","picture":"/authors/jj.jpeg"},"content":"\u003cp\u003eThe Null Object Pattern is a common way in OOP to handle \u003ccode\u003enull\u003c/code\u003e references in a graceful way. If a reference to an object is \u003ccode\u003enull\u003c/code\u003e and a method is invoked on that reference, then this will cause an error. Instead, a Null Object can be implemented with the same interface, but where the methods are no-op methods. Other objects can inherit from this Null Object in such a way, that if a \u003ccode\u003enull\u003c/code\u003e reference is passed then they will use the no-op methods from the Null Object rather than throwing an error.\u003c/p\u003e\n\u003cp\u003eWhy not just use conditional checks using \u003ccode\u003eif\u003c/code\u003e statements to check for null? You certainly can. But in OOP it is prefered to use polymorphism over conditionals where possible. In FP, there isn't really an exact counterpart to polymorphism so replicating it takes some adaptation. But in both paradigms, the avoidance of conditionals and \u003ccode\u003eif\u003c/code\u003e statements is desired and can be achieved because the goal is to reduce branching in the program. The problem with handling \u003ccode\u003enull\u003c/code\u003e is that it necessarily adds branching to your logic, because you now have to handle another case. But the Null Object Pattern, while not completely removing it, can at least encapsulate and hide that branching for us.\u003c/p\u003e\n\u003ch2\u003eTypical OOP implementation in JS\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003eclass Discount {\n  calculateDiscount() {\n    return 0.15;\n  }\n}\nclass NoDiscount {\n  calculateDiscount() {\n    return null;\n  }\n}\nfunction getDiscount(orderType) {\n  return orderType === \u0026quot;matin√©e\u0026quot; ? new Discount() : new NoDiscount();\n}\n\n[getDiscount(\u0026quot;matin√©e\u0026quot;), null].map((o) =\u0026gt; getDiscount(o).calculateDiscount()); // [0.15, null]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUsing the null object pattern, a special version of the Class is created that has the same method and signature, but it only handles \u003ccode\u003enull\u003c/code\u003e values and mitigates the need for more tedious control flow logic that checks for \u003ccode\u003enull\u003c/code\u003e values in the original class interface.\u003c/p\u003e\n\u003ch2\u003eTypical Functional implementation in JS\u003c/h2\u003e\n\u003cp\u003ePreviously we saw a way to implement the Null Object Pattern in an OOP style. A functional style of handling it would look like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003efunction Discounts(type) {\n  let types = {\n    regular: {\n      calc() {\n        return 0.15;\n      },\n    },\n    nullDiscount: {\n      calc() {\n        return null;\n      },\n    },\n  };\n  return types[type] || types.nullDiscount;\n}\nDiscounts(\u0026quot;regular\u0026quot;).calc(); // 0.15\nDiscounts(null).calc(); // null\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eECMAScript 2020: Is this pattern necessary anymore?\u003c/h2\u003e\n\u003cp\u003eIn the latest version of ECMAScript there are a couple of operators that more or less obviate the need to implement a custom Null Object handler. They are called Optional Chaining (\u003ccode\u003e?.\u003c/code\u003e) and Nullish Coalescing (\u003ccode\u003e??\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eOptional Chaining can be used when trying to access methods or properties on any object such that accessing an undefined property will not cause an error and instead it can be handled with minimal control flow. It would look like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003eclass Discount {\n  calc() {\n    return 0.15;\n  }\n  days = \u0026quot;MTWTF\u0026quot;;\n}\nlet special = new Discount();\nspecial.calc?.(); // 0.15\nspecial.order(); // Uncaught TypeError ü§¨\nspecial.order?.(); // undefined (ok, that's better)\nspecial.order?.() || \u0026quot;No specials\u0026quot;; // 'No specials' (NICE!)\nspecial.day; // undefined anyways so optional chaining is not needed for properties\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen we call the non-existent \u003ccode\u003eorder\u003c/code\u003e method unsafely we get an uncaught type error ü§¨. We want to avoidthat at all costs. Optional chaining allows us to call \u003ccode\u003eorder\u003c/code\u003e in a safe way which can be handled by error paths in the code relatively easily.\u003c/p\u003e\n\u003cp\u003eThis works the same for JS objects:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003elet obj = {\n  days: 'MWT',\n  order: () =\u0026gt; ['burger', 'fries']\n  points: () =\u0026gt; 0\n}\n\nobj.day // undefined already (it's a property, not a method)\nobj.special() // Uncaught TypeError ü§¨\nobj.special?.() // undefined\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd we can combine this with Nullish Coallescing to get a fully operational Null Object Handling that also respects intentional falsey values. It's a one liner that can fit anywhere in our code when referencing potentially non-existent methods:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003e// using `obj` from previous code block\nobj.special?.() ?? \u0026quot;No Special\u0026quot;; // 'No Special'\nobj.points?.() || \u0026quot;Could not fetch points\u0026quot;; // 'Could not fetch points'\nobj.points?.() ?? \u0026quot;Could not fetch points\u0026quot;; // 0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSo we can see the Nullish Coalescer allows us to handle null and undefined methods alongside methods that may return falsy values like \u003ccode\u003e0\u003c/code\u003e or \u003ccode\u003e''\u003c/code\u003e or \u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eSo is optional chaining combined with nullish coalescing enough to recreate the Null Object pattern in JS? I think so, but perhaps others may still build something more robust like Maybe Monads or Null Object Handling Classes. But I'll be reaching for hese two new tools, optional chaing and nullish coallescing, in ECMAScript first in my programs before opting to go with the more complex patterns.\u003c/p\u003e\n","ogImage":{"url":"/img/cover.jpg"},"coverImage":"/img/cover.jpg"}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"null_object_fp"},"buildId":"obrXrIdU6aRWSbL_OwLjq","assetPrefix":"/log","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>