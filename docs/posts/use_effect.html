<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png"/><link rel="manifest" href="/favicons/site.webmanifest"/><link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicons/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta name="description" content="Thoughts on our awesome collective web platform."/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>React&#x27;s useEffect as an &quot;Event Listener&quot; | Make Devs</title><meta property="og:image" content="/img/cover.jpg"/><meta name="next-head-count" content="16"/><link rel="preload" href="/log/_next/static/css/0dff263c2b12f909.css" as="style"/><link rel="stylesheet" href="/log/_next/static/css/0dff263c2b12f909.css" data-n-g=""/><link rel="preload" href="/log/_next/static/css/cf121497002c184d.css" as="style"/><link rel="stylesheet" href="/log/_next/static/css/cf121497002c184d.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/log/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/log/_next/static/chunks/webpack-c6d930e7ce3de825.js" defer=""></script><script src="/log/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/log/_next/static/chunks/main-b58ac34e0b98c3ee.js" defer=""></script><script src="/log/_next/static/chunks/pages/_app-90e414d931afb8eb.js" defer=""></script><script src="/log/_next/static/chunks/893-bb16ac16a245221e.js" defer=""></script><script src="/log/_next/static/chunks/349-6549a57f16834f01.js" defer=""></script><script src="/log/_next/static/chunks/pages/posts/%5Bslug%5D-1c5fb752600b548b.js" defer=""></script><script src="/log/_next/static/vhkVjWy1EPmybrLuHRQj0/_buildManifest.js" defer=""></script><script src="/log/_next/static/vhkVjWy1EPmybrLuHRQj0/_ssgManifest.js" defer=""></script><script src="/log/_next/static/vhkVjWy1EPmybrLuHRQj0/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="min-h-screen"><main><div class="container mx-auto px-5"><h2 class="text-2xl md:text-4xl font-bold tracking-tight md:tracking-tighter leading-tight mb-20 mt-8"><a class="hover:underline" href="/log">Make üèóÔ∏è Devs</a></h2><article class="mb-32"><div class="-mb-36 md:-mb-36 sm:-mx-8"><div class="sm:mx-0"><img src="/log//img/cover.jpg" alt="Cover Image for React&#x27;s useEffect as an &quot;Event Listener&quot;" class="responsive shadow-sm" width="310" height="160"/></div></div><h1 class="text-4xl md:text-5xl lg:text-6xl font-bold tracking-tighter leading-tight md:leading-none mb-12 text-center" style="transform:translateZ(0);background-image:radial-gradient(white 30%, transparent 50%)">React&#x27;s useEffect as an &quot;Event Listener&quot;</h1><div class="mb-6 text-lg flex justify-around" style="transform:translateZ(0)"><time dateTime="2021-02-05T10:35:07.322Z">February	5, 2021</time><div class="flex items-center"><img src="/log//authors/jj.jpeg" class="w-12 h-12 rounded-full mr-4" alt="Jamie Vaughn"/><div class="text-xl font-bold">Jamie Vaughn</div></div></div><div class="max-w-2xl mx-auto"><div class="markdown-styles_markdown__h_8de"><p>React Hooks are amazing. I find they make it incredibly easy to modularize any piece of logic and then use it seemlessly anywhere in your app. We now get statefulness or statelessness within a consistent function component API by recasting lifecycle hooks as a set of distinct, composable event subscription methods or &quot;Hooks&quot;. This lets us cleanly group state/action/effect by feature or component, effectively providing us with extensible mixins lacking in <code>Class</code> components. Yes, there were HOCs for <code>Class</code> components but those were kludgy for sharing non-presentational logic, with Hooks the non-presentational logic can be easily composed and shared in a function's closure.</p>
<p>One Hook in particular, <code>useEffect()</code> is extremely powerful, but it is also confusing especially to those learning a Javascript framework for the first time. I also sometimes hear of veteran React users lamenting the demise of React's life cycle methods and deriding <code>useEffect()</code> as a step backwards in some way from those.</p>
<p>But I strongly disagree. The more that I use <code>useEffect()</code>, the more I think the whole concept of life cycle methods were a kludge that was leading us astray all along. On some days, I might even go so far as to say they are an anti-pattern.</p>
<p>That might sound harsh, but let me explain.</p>
<p>The life cycle methods (componentWillMount, componentWillUpdate, componentWillUnmount, etc.) trigger when a component life cycle reaches a certain point or time in the render cycle. This is really just a disguised equivalent to having hard-coded checkpoints in your code to give you an opportunity to make assertions or control flow statements and run some other logic depending on a condition. This is essentially a slightly more sophisticated form of Polling.</p>
<p>But if we think about this, we ought never to really need to run code after some inflexible elapsed interval of time (i.e. a life-cycle point). That is what Polling does. On the contrary, what we NEED is to run code when a value changes. If we can set up some observer that notifies us of that change, then we can run that logic only when it is absolutely needed. This is what useEffect now grants us.</p>
<p>Polling is discouraged these days for good reason, but it was at one time a common pattern in apps, before the days of callbacks. Callbacks were an improvement asynchronous processing that liberated developers from the terrible anti-pattern of Polling with <code>setTimeout()</code> or <code>setInterval()</code>. But callbacks quickly led to callback hell which is why it is also a kludge that has been supplanted by other, better asynchronous patterns like Promises and Async/Await.</p>
<p>Similarly to callbacks, life cycle methods are a kludge to avoid the hell of having no way to listen to your app's internal state-change events for the purpose of notifying some other part of the app to execute some side effect. But, with <code>useEffect()</code> we now get an asynchronous pattern to help us manage that in a way that is on par with the introduction of Promises to better compose callbacks.</p>
<p>With <code>useEffect()</code>, we essentially have an off-the-shelf <code>addEventListener()</code> where the event being listened to can be a change in any piece of app state that we want (i.e. whatever we put in the dependency array).</p>
<p>So Promises let us sequentially tie an initiation of a callback to a trigger, independently of time. And <code>useEffect()</code> let's sequentially tie a callback to a change in a value of interest. You can think of this trigger as an &quot;app state event&quot;, which is no different conceptually to the browser events were familiar with like <code>&quot;click&quot;</code>, <code>&quot;mouseover&quot;</code>, <code>&quot;scroll&quot;</code>, etc. But now instead of a set number of listenable events provided to us from the browser, we can now listen to a change on any and every variable in our app.</p>
<p>Consider if the authors of React had made the call signature of <code>useEffect()</code> more like <code>addEvenListener()</code>:</p>
<pre><code class="language-js">useEffectListener([foo], () =&gt; {
  // do side effects
});

addEventListener(&quot;click&quot;, (e) =&gt; {
  // do side effects
});
</code></pre>
<p>Above our <code>useEffect()</code> Hook is rewritten slightly to look more like the familiar <code>addEventListener()</code> and its immediately clear the event being listened to is a change in <code>foo</code> after which it will run the function passed as the second parameter... just like with <code>addEventListener()</code>. Furthermore, since <code>foo</code> is in an array, the Hook's api probably affords us the opportunity to listen to multiple values simultaneously. Convenient! I think this Hook would be understood much more intuitively by developers coming from vanilla Javascript if it is thought of in this way.</p>
</div></div></article></div><div class="text-center text-2xl my-16 underline"><a href="/log/posts">Read Another!</a></div></main></div><footer class="relative bg-accent-1 border-t border-accent-2"><div class="container mx-auto px-5"><div class="py-12 flex flex-col lg:flex-row items-center"><h3 class="text-4xl lg:text-5xl font-bold tracking-tighter leading-tight text-center lg:text-left mb-10 lg:mb-0 lg:pr-4 lg:w-1/2">Make üèóÔ∏è Devs</h3><div class="flex flex-col lg:flex-row justify-end items-center lg:pl-4 lg:w-1/2"><a href="https://wjv.io" class="mx-3 bg-black hover:bg-white hover:text-black border border-black text-white font-bold py-2 px-8 lg:px-8 duration-200 transition-colors mb-6 lg:mb-0">Portfolio</a><a href="https://github.com/JamieVaughn/log" class="mx-3 font-bold hover:underline">View on GitHub</a></div></div></div><span class="absolute bottom-1 right-2">graphics from <span class="underline"><a href="https://designs.ai/graphicmaker">designs.ai</a></span></span></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"React's useEffect as an \"Event Listener\"","date":"2021-02-05T10:35:07.322Z","slug":"use_effect","author":{"name":"Jamie Vaughn","picture":"/authors/jj.jpeg"},"content":"\u003cp\u003eReact Hooks are amazing. I find they make it incredibly easy to modularize any piece of logic and then use it seemlessly anywhere in your app. We now get statefulness or statelessness within a consistent function component API by recasting lifecycle hooks as a set of distinct, composable event subscription methods or \u0026quot;Hooks\u0026quot;. This lets us cleanly group state/action/effect by feature or component, effectively providing us with extensible mixins lacking in \u003ccode\u003eClass\u003c/code\u003e components. Yes, there were HOCs for \u003ccode\u003eClass\u003c/code\u003e components but those were kludgy for sharing non-presentational logic, with Hooks the non-presentational logic can be easily composed and shared in a function's closure.\u003c/p\u003e\n\u003cp\u003eOne Hook in particular, \u003ccode\u003euseEffect()\u003c/code\u003e is extremely powerful, but it is also confusing especially to those learning a Javascript framework for the first time. I also sometimes hear of veteran React users lamenting the demise of React's life cycle methods and deriding \u003ccode\u003euseEffect()\u003c/code\u003e as a step backwards in some way from those.\u003c/p\u003e\n\u003cp\u003eBut I strongly disagree. The more that I use \u003ccode\u003euseEffect()\u003c/code\u003e, the more I think the whole concept of life cycle methods were a kludge that was leading us astray all along. On some days, I might even go so far as to say they are an anti-pattern.\u003c/p\u003e\n\u003cp\u003eThat might sound harsh, but let me explain.\u003c/p\u003e\n\u003cp\u003eThe life cycle methods (componentWillMount, componentWillUpdate, componentWillUnmount, etc.) trigger when a component life cycle reaches a certain point or time in the render cycle. This is really just a disguised equivalent to having hard-coded checkpoints in your code to give you an opportunity to make assertions or control flow statements and run some other logic depending on a condition. This is essentially a slightly more sophisticated form of Polling.\u003c/p\u003e\n\u003cp\u003eBut if we think about this, we ought never to really need to run code after some inflexible elapsed interval of time (i.e. a life-cycle point). That is what Polling does. On the contrary, what we NEED is to run code when a value changes. If we can set up some observer that notifies us of that change, then we can run that logic only when it is absolutely needed. This is what useEffect now grants us.\u003c/p\u003e\n\u003cp\u003ePolling is discouraged these days for good reason, but it was at one time a common pattern in apps, before the days of callbacks. Callbacks were an improvement asynchronous processing that liberated developers from the terrible anti-pattern of Polling with \u003ccode\u003esetTimeout()\u003c/code\u003e or \u003ccode\u003esetInterval()\u003c/code\u003e. But callbacks quickly led to callback hell which is why it is also a kludge that has been supplanted by other, better asynchronous patterns like Promises and Async/Await.\u003c/p\u003e\n\u003cp\u003eSimilarly to callbacks, life cycle methods are a kludge to avoid the hell of having no way to listen to your app's internal state-change events for the purpose of notifying some other part of the app to execute some side effect. But, with \u003ccode\u003euseEffect()\u003c/code\u003e we now get an asynchronous pattern to help us manage that in a way that is on par with the introduction of Promises to better compose callbacks.\u003c/p\u003e\n\u003cp\u003eWith \u003ccode\u003euseEffect()\u003c/code\u003e, we essentially have an off-the-shelf \u003ccode\u003eaddEventListener()\u003c/code\u003e where the event being listened to can be a change in any piece of app state that we want (i.e. whatever we put in the dependency array).\u003c/p\u003e\n\u003cp\u003eSo Promises let us sequentially tie an initiation of a callback to a trigger, independently of time. And \u003ccode\u003euseEffect()\u003c/code\u003e let's sequentially tie a callback to a change in a value of interest. You can think of this trigger as an \u0026quot;app state event\u0026quot;, which is no different conceptually to the browser events were familiar with like \u003ccode\u003e\u0026quot;click\u0026quot;\u003c/code\u003e, \u003ccode\u003e\u0026quot;mouseover\u0026quot;\u003c/code\u003e, \u003ccode\u003e\u0026quot;scroll\u0026quot;\u003c/code\u003e, etc. But now instead of a set number of listenable events provided to us from the browser, we can now listen to a change on any and every variable in our app.\u003c/p\u003e\n\u003cp\u003eConsider if the authors of React had made the call signature of \u003ccode\u003euseEffect()\u003c/code\u003e more like \u003ccode\u003eaddEvenListener()\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003euseEffectListener([foo], () =\u0026gt; {\n  // do side effects\n});\n\naddEventListener(\u0026quot;click\u0026quot;, (e) =\u0026gt; {\n  // do side effects\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAbove our \u003ccode\u003euseEffect()\u003c/code\u003e Hook is rewritten slightly to look more like the familiar \u003ccode\u003eaddEventListener()\u003c/code\u003e and its immediately clear the event being listened to is a change in \u003ccode\u003efoo\u003c/code\u003e after which it will run the function passed as the second parameter... just like with \u003ccode\u003eaddEventListener()\u003c/code\u003e. Furthermore, since \u003ccode\u003efoo\u003c/code\u003e is in an array, the Hook's api probably affords us the opportunity to listen to multiple values simultaneously. Convenient! I think this Hook would be understood much more intuitively by developers coming from vanilla Javascript if it is thought of in this way.\u003c/p\u003e\n","ogImage":{"url":"/img/cover.jpg"},"coverImage":"/img/cover.jpg"}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"use_effect"},"buildId":"vhkVjWy1EPmybrLuHRQj0","assetPrefix":"/log","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>