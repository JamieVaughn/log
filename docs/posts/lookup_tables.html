<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png"/><link rel="manifest" href="/favicons/site.webmanifest"/><link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicons/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta name="description" content="Thoughts on our awesome collective web platform."/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>Lookup-Table Syntax Options in Javascript | Make Devs</title><meta property="og:image" content="/img/cover.jpg"/><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/0dff263c2b12f909.css" as="style"/><link rel="stylesheet" href="/_next/static/css/0dff263c2b12f909.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cf121497002c184d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cf121497002c184d.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-9b312e20a4e32339.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-83803dd478f5b5bc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-90e414d931afb8eb.js" defer=""></script><script src="/_next/static/chunks/893-bb16ac16a245221e.js" defer=""></script><script src="/_next/static/chunks/349-6549a57f16834f01.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-526ce38baf3fe719.js" defer=""></script><script src="/_next/static/T5fTCCVyxYKAMt_HWbgoR/_buildManifest.js" defer=""></script><script src="/_next/static/T5fTCCVyxYKAMt_HWbgoR/_ssgManifest.js" defer=""></script><script src="/_next/static/T5fTCCVyxYKAMt_HWbgoR/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="min-h-screen"><main><div class="container mx-auto px-5"><h2 class="text-2xl md:text-4xl font-bold tracking-tight md:tracking-tighter leading-tight mb-20 mt-8"><a class="hover:underline" href="/">Make üèóÔ∏è Devs</a></h2><article class="mb-32"><div class="-mb-36 md:-mb-36 sm:-mx-8"><div class="sm:mx-0"><img src="/img/cover.jpg" alt="Cover Image for Lookup-Table Syntax Options in Javascript" class="responsive shadow-sm" width="310" height="160"/></div></div><h1 class="text-4xl md:text-5xl lg:text-6xl font-bold tracking-tighter leading-tight md:leading-none mb-12 text-center" style="transform:translateZ(0);background-image:radial-gradient(white 30%, transparent 50%)">Lookup-Table Syntax Options in Javascript</h1><div class="mb-6 text-lg flex justify-around" style="transform:translateZ(0)"><time dateTime="2020-07-20T08:50:00.322Z">July	20, 2020</time><div class="flex items-center"><img src="/authors/jj.jpeg" class="w-12 h-12 rounded-full mr-4" alt="Jamie Vaughn"/><div class="text-xl font-bold">Jamie Vaughn</div></div></div><div class="max-w-2xl mx-auto"><div class="markdown-styles_markdown__h_8de"><p>Most event-based programming, whether it is for UI or not, needs a way to map some list of actions or inputs to blocks of logic to execute. Procedural Programming may not need this because the entire program is expected to run synchronously and in order. But when responding to events, code will not execute in a predictable order, which requires a good way to organize the possible blocks of logic that may need to run at these asynchronous times. The Asynchronicity, itself, is handled by other patterns (Promises, Futures, Observables Pub/Sub, etc.), but for organizing the callbacks of these patterns, lets take a look at some lookup-table implementation patterns. These patterns appear commonly in state management libraries like Redux and XState to manage state, dispatchers, and actions which may be triggered or transformed within a user interface.</p>
<h2>A Few Options for Authoring Lookup-Tables in JS</h2>
<ul>
<li>If statements (conventional or ternary)</li>
<li>Switch Statements</li>
<li>Objects/Maps (Lookup-Tables)</li>
</ul>
<p>First we have the humble <code>if</code> statement control flow implementation in both conventional and ternary syntax:</p>
<pre><code class="language-js">function getSound(str) {
  return test === &quot;cat&quot;
    ? &quot;meow&quot;
    : test === &quot;cow&quot;
    ? &quot;moo&quot;
    : test === &quot;dog&quot;
    ? &quot;woof&quot;
    : test === &quot;bird&quot;
    ? &quot;chirp&quot;
    : test === &quot;frog&quot;
    ? &quot;ribit&quot;
    : &quot;silence&quot;;
}
</code></pre>
<p>Or the same logic but with conventional <code>if</code> / <code>else if</code> / <code>else</code> syntax:</p>
<pre><code class="language-js">function getSoundConv(str) {
  if (str === &quot;cat&quot;) return &quot;meow&quot;;
  else if (str === &quot;cow&quot;) return &quot;moo&quot;;
  else if (str === &quot;dog&quot;) return &quot;woof&quot;;
  else if (str === &quot;bird&quot;) return &quot;chirp&quot;;
  else if (str === &quot;frog&quot;) return &quot;ribit&quot;;
  else return &quot;silence&quot;;
}
</code></pre>
<p>Control flow implementations necessarily introduce <a href="https://en.wikipedia.org/wiki/Cyclomatic_complexity">cyclomatic complexity</a> meaning there is branching logic within one's code. This is considered somewhat of a code smell in the Functional Paradigm because it imposes a cost on code readability. The next two implementations avoid the control flow pattern and thus reduce cyclomatic complexity. They make it eaiser to map pieces of UI directly to blocks of logic, rather than routing multiple UI element events through one imperative block of logic that the control flow must untangle.</p>
<p>The first of the &quot;non-control flow&quot; options is a lookup-table implemented via a <code>switch</code> statement:</p>
<pre><code class="language-js">function switchSound(str) {
  switch (str) {
    case &quot;cat&quot;:
      return &quot;meow&quot;;
    case &quot;dog&quot;:
      return &quot;woof&quot;;
    case &quot;cow&quot;:
      return &quot;moo&quot;;
    case &quot;bird&quot;:
      return &quot;chirp&quot;;
    case &quot;frog&quot;:
      return &quot;ribit&quot;;
    default:
      return &quot;silence&quot;;
  }
}
</code></pre>
<p>And next we have an example of a lookup-table function using a simple object factory:</p>
<pre><code class="language-js">function factorySound(str) {
  return (
    {
      cat: &quot;meow&quot;,
      dog: &quot;woof&quot;,
      cow: &quot;moo&quot;,
      bird: &quot;chirp&quot;,
      frog: &quot;ribit&quot;,
    }[str] ?? &quot;silence&quot;
  );
}
</code></pre>
<p>The above implementation uses a factory function that returns plain JS objects, but would look about the same using a Map() or WeakMap(). An easy extra optimization that can be made with this approach is defining the object externally to the function in order to limit how many of these objects are created in memory. Then the function is simply a getter for that object, essentially.</p>
<pre><code class="language-js">// same obj as above just defined outside function.
const Animals = {cat: 'meow', ... }
function factorySound(str) {
  return Animals[str] ?? 'silence'
}
</code></pre>
<p>Going this route suggests that the factorySound function could be abstracted to a general <code>factoryValue</code> function and could be used on any object that you define in your application:</p>
<pre><code class="language-js">function factoryValue(obj, str, default = 'silence') {
  return obj[str] ?? default
}
</code></pre>
<p>All four of the functions above will provide an easy API for retrieving values by passing in a simple enum.
We can test the functions with something simple to inspect their output and we would get something like this:</p>
<pre><code class="language-js">console.log(getSound(&quot;dog&quot;)); // 'woof'
console.log(getSoundConv(&quot;cow&quot;)); // 'moo'
console.log(switchSound(&quot;cat&quot;)); // 'meow'
console.log(factorySound(&quot;snake&quot;)); // 'silence'
</code></pre>
<h3>Which to favor?</h3>
<p>This is subjective as any of the styles work in the expected way. The decision of which to use comes down to two things, I think: (1) Readability and (2) Extensibility.</p>
<p>In my opinion, both of the <code>if</code> statement styles are the least readable. The conventional <code>if</code> statement style would at least offer you better extensibility over the ternary style since you can more easily use multi-line code for more complex logic. But the extensibility is matched or exceeded by the switch and factory styles, so I think it's safe to lay the <code>if</code> statement style aside in favor of one of the next two styles.</p>
<p>Between the <code>switch</code> style and the factory style, I think there is a fair argument to be made for both. The object factory style's advantage is that, as an object, it is quite literally a map or a key-value store. So it is the thing we set out to recreate, meaning what we see is what we want it to be and not some adaptation or hack. So in terms of readability, I'd give the edge to the oject factory table syntax.</p>
<p>In terms of extensibility, both the <code>switch</code> and facotry styles permit multi-line space for complex execution logic. Both can be adapted to use a more declarative style over an imperative style by returning a function instead of executing procedural logic in place. The switch statement <code>case</code> block and the factory table allow convenient non-co-located function definitions to be mapped to the keys or <code>case</code> block without being invoked inline. So both permit easily passing function callbacks around our program for lazy execution and taking better advantage of closures. And both equally reduce cyclomatic complexity by mapping an enum directly to a block of logic, which reduces code branching unlike the <code>if</code> statements.</p>
<p>Perhaps the key distinction is the <code>switch</code> statement has more flexibility than the factory table by not being constrained only to enums as the access API. The <code>switch</code> statement can also accomodate comparisons to map to execution blocks, which may suit one's program in particular situations. In most situations enums are prefered for readability and are usually good enough, but having the additional flexibility of comparators may explain why <code>switch</code> statements seem more popular in Reducer utilities, like React's <code>useReducer</code> and Redux, within the functional community.</p>
<h3>Use Cases</h3>
<p>A common use case for this pattern is for mapping blocks of code to execute for each UI element that triggers an event. A pitfall that leads to unnecessary cyclomatic complexity is relying on a single function as a callback when any one of an entire set of buttons is clicked. This callback would typically work out which code to execute within the function by using control flow to check either some background global state or checking some flag parameter that is passed in.</p>
<p>The lookup-table pattern lets us separate out the logic of determining which code block to execute into its own structure (i.e. one of the lookup functions above). Then the return value from that lookup-table funciton would, ultimately, be the code block that needs to be executed as a result of the triggering event. Emerging from this pattern is that the control flow mentioned in the previous paragraph simply falls away if the UI is setup accordingly. The UI element can contain the enum value that will be passed in the event object that bubbles and the lookup-table can retrieve the correct function without any control flow using the event object properties. This is what is meant by &quot;pushing cyclomatic complexity out&quot;. The logic branching still technically exists in the program, but we've pushed it all the way into the UI layer (instead of it being in the business logic layer) which simplifies our code. Since the branch now implicitly occurs before the moment of user input, the branch logic never explicitly appears in the code itself.</p>
<h5>An Example</h5>
<p>Let's take a simple contrived example of a drop down menu:</p>
<p>The HTML might be something like this:</p>
<pre><code class="language-html">&lt;label for=&quot;choices&quot;&gt;Listen to an animal's call:&lt;/label&gt;
&lt;select id=&quot;choices&quot; onchange=&quot;factorySound(event.target.value)&quot;&gt;
  &lt;option value=&quot;dog&quot;&gt;Dog&lt;/option&gt;
  &lt;option value=&quot;cat&quot;&gt;Cat&lt;/option&gt;
  &lt;option value=&quot;bird&quot;&gt;Bird/option&gt;&lt;/option&gt;
  &lt;option value=&quot;cow&quot;&gt;Cow&lt;/option&gt;
  &lt;option value=&quot;bear&quot;&gt;Bear&lt;/option&gt;
&lt;/select&gt;

&lt;img src=&quot;&quot; alt=&quot;animal&quot; id=&quot;selection&quot; /&gt;
</code></pre>
<p>And the javascript can use one of our lookup-tables from before, which you'll notice we can easily extend with a new <code>bear</code> field. We can also keep unused fields without consequence, like <code>frog</code>, which might be used in another UI component but won't be used in this one, and it will safely be inert here:</p>
<pre><code class="language-js">function factorySound(str) {
  return (
    {
      cat: soundAction(str, &quot;meow&quot;),
      dog: soundAction(str, &quot;woof&quot;),
      cow: soundAction(str, &quot;moo&quot;),
      bird: soundAction(str, &quot;chirp&quot;),
      frog: soundAction(str, &quot;ribit&quot;),
      bear: soundAction(str, &quot;roar&quot;),
    }[str] ?? soundAction(str, &quot;silence&quot;)
  );
}

function soundAction(str, sound) {
  console.log(sound);
  document
    .querySelector(&quot;#selection&quot;)
    .setAttribute(&quot;src&quot;, `https://pictureof${str}.com/200/300`);
}
</code></pre>
<p>We've also added a new function called <code>soundAction</code>, which can be the composable function that holds the actual business logic code block that should be run upon the event being triggered. It can contain any arbitrary logic, and of course different functions can be mapped to different lookup-table fields as needed for customizability. In this example, the busines logic just logs the animal sound and populates an image of the animal from a hypothetical animal picture API.</p>
<p>With this kind of organization (which resembles the formalized Command Pattern), you'll notice there are no if statements and no conventional control flow which means we keep our cyclomatic complexity to a minimum. We've pushed all of the logic branching up into the UI layer (which is as high as it can go) and we allow the event system itself to pass the information needed to run the correct code block.</p>
</div></div></article></div><div class="text-center text-2xl my-16 underline"><a href="/posts">Read Another!</a></div></main></div><footer class="relative bg-accent-1 border-t border-accent-2"><div class="container mx-auto px-5"><div class="py-12 flex flex-col lg:flex-row items-center"><h3 class="text-4xl lg:text-5xl font-bold tracking-tighter leading-tight text-center lg:text-left mb-10 lg:mb-0 lg:pr-4 lg:w-1/2">Make üèóÔ∏è Devs</h3><div class="flex flex-col lg:flex-row justify-end items-center lg:pl-4 lg:w-1/2"><a href="https://wjv.io" class="mx-3 bg-black hover:bg-white hover:text-black border border-black text-white font-bold py-2 px-8 lg:px-8 duration-200 transition-colors mb-6 lg:mb-0">Portfolio</a><a href="https://github.com/JamieVaughn/log" class="mx-3 font-bold hover:underline">View on GitHub</a></div></div></div><span class="absolute bottom-1 right-2">graphics from <span class="underline"><a href="https://designs.ai/graphicmaker">designs.ai</a></span></span></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Lookup-Table Syntax Options in Javascript","date":"2020-07-20T08:50:00.322Z","slug":"lookup_tables","author":{"name":"Jamie Vaughn","picture":"/authors/jj.jpeg"},"content":"\u003cp\u003eMost event-based programming, whether it is for UI or not, needs a way to map some list of actions or inputs to blocks of logic to execute. Procedural Programming may not need this because the entire program is expected to run synchronously and in order. But when responding to events, code will not execute in a predictable order, which requires a good way to organize the possible blocks of logic that may need to run at these asynchronous times. The Asynchronicity, itself, is handled by other patterns (Promises, Futures, Observables Pub/Sub, etc.), but for organizing the callbacks of these patterns, lets take a look at some lookup-table implementation patterns. These patterns appear commonly in state management libraries like Redux and XState to manage state, dispatchers, and actions which may be triggered or transformed within a user interface.\u003c/p\u003e\n\u003ch2\u003eA Few Options for Authoring Lookup-Tables in JS\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eIf statements (conventional or ternary)\u003c/li\u003e\n\u003cli\u003eSwitch Statements\u003c/li\u003e\n\u003cli\u003eObjects/Maps (Lookup-Tables)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFirst we have the humble \u003ccode\u003eif\u003c/code\u003e statement control flow implementation in both conventional and ternary syntax:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003efunction getSound(str) {\n  return test === \u0026quot;cat\u0026quot;\n    ? \u0026quot;meow\u0026quot;\n    : test === \u0026quot;cow\u0026quot;\n    ? \u0026quot;moo\u0026quot;\n    : test === \u0026quot;dog\u0026quot;\n    ? \u0026quot;woof\u0026quot;\n    : test === \u0026quot;bird\u0026quot;\n    ? \u0026quot;chirp\u0026quot;\n    : test === \u0026quot;frog\u0026quot;\n    ? \u0026quot;ribit\u0026quot;\n    : \u0026quot;silence\u0026quot;;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOr the same logic but with conventional \u003ccode\u003eif\u003c/code\u003e / \u003ccode\u003eelse if\u003c/code\u003e / \u003ccode\u003eelse\u003c/code\u003e syntax:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003efunction getSoundConv(str) {\n  if (str === \u0026quot;cat\u0026quot;) return \u0026quot;meow\u0026quot;;\n  else if (str === \u0026quot;cow\u0026quot;) return \u0026quot;moo\u0026quot;;\n  else if (str === \u0026quot;dog\u0026quot;) return \u0026quot;woof\u0026quot;;\n  else if (str === \u0026quot;bird\u0026quot;) return \u0026quot;chirp\u0026quot;;\n  else if (str === \u0026quot;frog\u0026quot;) return \u0026quot;ribit\u0026quot;;\n  else return \u0026quot;silence\u0026quot;;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eControl flow implementations necessarily introduce \u003ca href=\"https://en.wikipedia.org/wiki/Cyclomatic_complexity\"\u003ecyclomatic complexity\u003c/a\u003e meaning there is branching logic within one's code. This is considered somewhat of a code smell in the Functional Paradigm because it imposes a cost on code readability. The next two implementations avoid the control flow pattern and thus reduce cyclomatic complexity. They make it eaiser to map pieces of UI directly to blocks of logic, rather than routing multiple UI element events through one imperative block of logic that the control flow must untangle.\u003c/p\u003e\n\u003cp\u003eThe first of the \u0026quot;non-control flow\u0026quot; options is a lookup-table implemented via a \u003ccode\u003eswitch\u003c/code\u003e statement:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003efunction switchSound(str) {\n  switch (str) {\n    case \u0026quot;cat\u0026quot;:\n      return \u0026quot;meow\u0026quot;;\n    case \u0026quot;dog\u0026quot;:\n      return \u0026quot;woof\u0026quot;;\n    case \u0026quot;cow\u0026quot;:\n      return \u0026quot;moo\u0026quot;;\n    case \u0026quot;bird\u0026quot;:\n      return \u0026quot;chirp\u0026quot;;\n    case \u0026quot;frog\u0026quot;:\n      return \u0026quot;ribit\u0026quot;;\n    default:\n      return \u0026quot;silence\u0026quot;;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd next we have an example of a lookup-table function using a simple object factory:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003efunction factorySound(str) {\n  return (\n    {\n      cat: \u0026quot;meow\u0026quot;,\n      dog: \u0026quot;woof\u0026quot;,\n      cow: \u0026quot;moo\u0026quot;,\n      bird: \u0026quot;chirp\u0026quot;,\n      frog: \u0026quot;ribit\u0026quot;,\n    }[str] ?? \u0026quot;silence\u0026quot;\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe above implementation uses a factory function that returns plain JS objects, but would look about the same using a Map() or WeakMap(). An easy extra optimization that can be made with this approach is defining the object externally to the function in order to limit how many of these objects are created in memory. Then the function is simply a getter for that object, essentially.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003e// same obj as above just defined outside function.\nconst Animals = {cat: 'meow', ... }\nfunction factorySound(str) {\n  return Animals[str] ?? 'silence'\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eGoing this route suggests that the factorySound function could be abstracted to a general \u003ccode\u003efactoryValue\u003c/code\u003e function and could be used on any object that you define in your application:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003efunction factoryValue(obj, str, default = 'silence') {\n  return obj[str] ?? default\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAll four of the functions above will provide an easy API for retrieving values by passing in a simple enum.\nWe can test the functions with something simple to inspect their output and we would get something like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003econsole.log(getSound(\u0026quot;dog\u0026quot;)); // 'woof'\nconsole.log(getSoundConv(\u0026quot;cow\u0026quot;)); // 'moo'\nconsole.log(switchSound(\u0026quot;cat\u0026quot;)); // 'meow'\nconsole.log(factorySound(\u0026quot;snake\u0026quot;)); // 'silence'\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eWhich to favor?\u003c/h3\u003e\n\u003cp\u003eThis is subjective as any of the styles work in the expected way. The decision of which to use comes down to two things, I think: (1) Readability and (2) Extensibility.\u003c/p\u003e\n\u003cp\u003eIn my opinion, both of the \u003ccode\u003eif\u003c/code\u003e statement styles are the least readable. The conventional \u003ccode\u003eif\u003c/code\u003e statement style would at least offer you better extensibility over the ternary style since you can more easily use multi-line code for more complex logic. But the extensibility is matched or exceeded by the switch and factory styles, so I think it's safe to lay the \u003ccode\u003eif\u003c/code\u003e statement style aside in favor of one of the next two styles.\u003c/p\u003e\n\u003cp\u003eBetween the \u003ccode\u003eswitch\u003c/code\u003e style and the factory style, I think there is a fair argument to be made for both. The object factory style's advantage is that, as an object, it is quite literally a map or a key-value store. So it is the thing we set out to recreate, meaning what we see is what we want it to be and not some adaptation or hack. So in terms of readability, I'd give the edge to the oject factory table syntax.\u003c/p\u003e\n\u003cp\u003eIn terms of extensibility, both the \u003ccode\u003eswitch\u003c/code\u003e and facotry styles permit multi-line space for complex execution logic. Both can be adapted to use a more declarative style over an imperative style by returning a function instead of executing procedural logic in place. The switch statement \u003ccode\u003ecase\u003c/code\u003e block and the factory table allow convenient non-co-located function definitions to be mapped to the keys or \u003ccode\u003ecase\u003c/code\u003e block without being invoked inline. So both permit easily passing function callbacks around our program for lazy execution and taking better advantage of closures. And both equally reduce cyclomatic complexity by mapping an enum directly to a block of logic, which reduces code branching unlike the \u003ccode\u003eif\u003c/code\u003e statements.\u003c/p\u003e\n\u003cp\u003ePerhaps the key distinction is the \u003ccode\u003eswitch\u003c/code\u003e statement has more flexibility than the factory table by not being constrained only to enums as the access API. The \u003ccode\u003eswitch\u003c/code\u003e statement can also accomodate comparisons to map to execution blocks, which may suit one's program in particular situations. In most situations enums are prefered for readability and are usually good enough, but having the additional flexibility of comparators may explain why \u003ccode\u003eswitch\u003c/code\u003e statements seem more popular in Reducer utilities, like React's \u003ccode\u003euseReducer\u003c/code\u003e and Redux, within the functional community.\u003c/p\u003e\n\u003ch3\u003eUse Cases\u003c/h3\u003e\n\u003cp\u003eA common use case for this pattern is for mapping blocks of code to execute for each UI element that triggers an event. A pitfall that leads to unnecessary cyclomatic complexity is relying on a single function as a callback when any one of an entire set of buttons is clicked. This callback would typically work out which code to execute within the function by using control flow to check either some background global state or checking some flag parameter that is passed in.\u003c/p\u003e\n\u003cp\u003eThe lookup-table pattern lets us separate out the logic of determining which code block to execute into its own structure (i.e. one of the lookup functions above). Then the return value from that lookup-table funciton would, ultimately, be the code block that needs to be executed as a result of the triggering event. Emerging from this pattern is that the control flow mentioned in the previous paragraph simply falls away if the UI is setup accordingly. The UI element can contain the enum value that will be passed in the event object that bubbles and the lookup-table can retrieve the correct function without any control flow using the event object properties. This is what is meant by \u0026quot;pushing cyclomatic complexity out\u0026quot;. The logic branching still technically exists in the program, but we've pushed it all the way into the UI layer (instead of it being in the business logic layer) which simplifies our code. Since the branch now implicitly occurs before the moment of user input, the branch logic never explicitly appears in the code itself.\u003c/p\u003e\n\u003ch5\u003eAn Example\u003c/h5\u003e\n\u003cp\u003eLet's take a simple contrived example of a drop down menu:\u003c/p\u003e\n\u003cp\u003eThe HTML might be something like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026lt;label for=\u0026quot;choices\u0026quot;\u0026gt;Listen to an animal's call:\u0026lt;/label\u0026gt;\n\u0026lt;select id=\u0026quot;choices\u0026quot; onchange=\u0026quot;factorySound(event.target.value)\u0026quot;\u0026gt;\n  \u0026lt;option value=\u0026quot;dog\u0026quot;\u0026gt;Dog\u0026lt;/option\u0026gt;\n  \u0026lt;option value=\u0026quot;cat\u0026quot;\u0026gt;Cat\u0026lt;/option\u0026gt;\n  \u0026lt;option value=\u0026quot;bird\u0026quot;\u0026gt;Bird/option\u0026gt;\u0026lt;/option\u0026gt;\n  \u0026lt;option value=\u0026quot;cow\u0026quot;\u0026gt;Cow\u0026lt;/option\u0026gt;\n  \u0026lt;option value=\u0026quot;bear\u0026quot;\u0026gt;Bear\u0026lt;/option\u0026gt;\n\u0026lt;/select\u0026gt;\n\n\u0026lt;img src=\u0026quot;\u0026quot; alt=\u0026quot;animal\u0026quot; id=\u0026quot;selection\u0026quot; /\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd the javascript can use one of our lookup-tables from before, which you'll notice we can easily extend with a new \u003ccode\u003ebear\u003c/code\u003e field. We can also keep unused fields without consequence, like \u003ccode\u003efrog\u003c/code\u003e, which might be used in another UI component but won't be used in this one, and it will safely be inert here:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003efunction factorySound(str) {\n  return (\n    {\n      cat: soundAction(str, \u0026quot;meow\u0026quot;),\n      dog: soundAction(str, \u0026quot;woof\u0026quot;),\n      cow: soundAction(str, \u0026quot;moo\u0026quot;),\n      bird: soundAction(str, \u0026quot;chirp\u0026quot;),\n      frog: soundAction(str, \u0026quot;ribit\u0026quot;),\n      bear: soundAction(str, \u0026quot;roar\u0026quot;),\n    }[str] ?? soundAction(str, \u0026quot;silence\u0026quot;)\n  );\n}\n\nfunction soundAction(str, sound) {\n  console.log(sound);\n  document\n    .querySelector(\u0026quot;#selection\u0026quot;)\n    .setAttribute(\u0026quot;src\u0026quot;, `https://pictureof${str}.com/200/300`);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe've also added a new function called \u003ccode\u003esoundAction\u003c/code\u003e, which can be the composable function that holds the actual business logic code block that should be run upon the event being triggered. It can contain any arbitrary logic, and of course different functions can be mapped to different lookup-table fields as needed for customizability. In this example, the busines logic just logs the animal sound and populates an image of the animal from a hypothetical animal picture API.\u003c/p\u003e\n\u003cp\u003eWith this kind of organization (which resembles the formalized Command Pattern), you'll notice there are no if statements and no conventional control flow which means we keep our cyclomatic complexity to a minimum. We've pushed all of the logic branching up into the UI layer (which is as high as it can go) and we allow the event system itself to pass the information needed to run the correct code block.\u003c/p\u003e\n","ogImage":{"url":"/img/cover.jpg"},"coverImage":"/img/cover.jpg"}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"lookup_tables"},"buildId":"T5fTCCVyxYKAMt_HWbgoR","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>