{"pageProps":{"post":{"tags":["Javascript"],"title":"The Good and Bad Parts of JS (according to Kyle Simpson)","date":"2019-12-31T20:50:07.322Z","slug":"good_parts_simpson","author":{"name":"Jamie Vaughn","picture":"/authors/jj.jpeg"},"content":"<p>Last time I summarized the good and bad parts of Javascript according to Douglas Crockford... Now I want to do the same according to Kyle Simpson, another Javascript expert I deeply respect. I gathered these opinions from several of Kyle Simpson's lecture on youtube and Linkedin Learning, especially his lectures on ES6, Coercion and Async Patterns.</p>\n<h2>Some Bad Parts</h2>\n<ol>\n<li>The <code>new</code> keyword. Simpson advises to <em>never</em> use it, with only two exceptions: (1) <code>new Regex(&quot;a*b&quot;, &quot;i&quot;)</code> if you absolutely need dynamic regular expressions (other just use static <code>/a*b/i</code> syntax) and (2) `new Date() because that's the only way to get the date.</li>\n<li><code>toString()</code> method on the Array &amp; Object natives since they return misleading values. Simpson recommends writing your own <code>toString()</code> methods in these two cases... i.e. calling the <code>JSON.stringify() method</code> as a custom <code>toString()</code> method on the Object prototype.</li>\n</ol>\n<h2>Some Overated Parts</h2>\n<ol>\n<li>The Arrow function is not widely needed... only for lexical scoping... i.e. binding <code>this</code> to outer scope\n<blockquote>\n<p>I disagree here but not all that strongly. I still use function declarations often for hoisting myself, but find concise arrow functions to be preferred whenever I reach for a function expression. And for callbacks, arrow functions are preferred. Simpson, himself, later on in the lectures I took this from, calls out several prominent use cases for the Arrow function, so this recommendation of his might be exaggerated.</p>\n</blockquote>\n</li>\n<li>The &quot;Death of Var&quot;... in other words, <code>let</code> and <code>const</code> do not make <code>var</code> obsolete. It is still needed for cross scope accessibility</li>\n<li><code>const</code> is actually not widely needed... (Protecting objects/properties is needed, but not loose variables so most times what you actually want is <code>Object.freeze</code>)</li>\n</ol>\n<h2>Some Good Parts</h2>\n<ol>\n<li>Type Coercion: Simpson recommends using explicit coercion whenever possible: <code>String()</code>, <code>Number()</code>, <code>Boolean()</code>. Don't use <code>toString()</code> or &quot;clever coercion&quot; like <code>+</code>, <code>!!</code></li>\n<li><code>let</code> is great for its auto-closure in <code>for</code> loops and other block scopes (but still doesn't replace var)</li>\n<li>Tagged Templates or Tag functions with Template strings... has led to many useful tag function libraries</li>\n</ol>\n<pre><code class=\"language-js\">function greet() {\n  return arguments;\n}\nvar person = { name: &quot;Jon&quot;, age: 28 };\n// A tagged template is a function call that uses a template literal from which to get its arguments\ngreet`I'm ${person.name}. I'm ${person.age} years old.`;\n// Arguments: [['I'm ', '. I'm ', ' years old.'], 'Jon', 28]\n</code></pre>\n<ol start=\"4\">\n<li>Rest (&quot;gather&quot;) and Spread operators make JS syntax much more declarative</li>\n<li>Default parameter values are awesome!! Default value can even be a function for logical defaults:</li>\n</ol>\n<pre><code class=\"language-js\">function foo(id = generateID()) {\n  //if foo is called with a user ID,\n  //then a new ID is generated and assigned for the new user\n}\n//OR enforce a psuedo type with manual exceptions\nconst required = (param) =&gt; throw &quot;Missing required &quot; + param;\nfunction foo(id = required(&quot;id&quot;)) {}\n</code></pre>\n<p>Default parameters can also be used in combination with the Rest operator and can be used safely with a function that returns an empty Array or Object as a default object assignment instead of using the conventional default assignment using <code>||</code>.</p>\n<pre><code class=\"language-js\">// old way\nfunction printObj(obj) {\n  let myObj = obj || {};\n  console.log(myObj);\n}\n// new way with default params\nfunction defaultPrint(obj = {}) {\n  console.log(obj);\n}\n</code></pre>\n<ol start=\"6\">\n<li>Generators... they are basically a state machine with lazy evaluation since it pauses between calls.</li>\n</ol>\n<pre><code class=\"language-js\">// Can be coupled with while loops for endless generators:\nfunction* uniqueID() {\n  while (true) {\n    yield Math.random();\n  }\n}\nvar num = () =&gt; uniqueID().next().value;\nnum();\n</code></pre>\n<blockquote>\n<p>I love this take on generators. As long as we remember these generators are usually not pure functions we can still use them for a surprisingly large number of use cases. Since UI often tends to be best modeled as a finite state machine, generators can often model UI states very well.</p>\n</blockquote>\n","ogImage":{"url":"/img/cover.jpg"},"coverImage":"/img/cover.jpg"}},"__N_SSG":true}