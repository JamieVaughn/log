{"pageProps":{"post":{"tags":["Javascript"],"title":"Nullish Checking in Javascript","date":"2022-02-11T11:25:07.322Z","slug":"nullish_checking_js","author":{"name":"Jamie Vaughn","picture":"/authors/jj.jpeg"},"content":"<h2>What are Null Checks and What is Nullish?</h2>\n<p>As programmers we often need to do some ad-hoc type checking for various reasons in our code. A common case is type checking of arguments passed into functions to make sure the subsequent operations and methods you use are supported by the argument type. One of the most frequent type checking needs is to make sure the parameters are not null, because null does not support any methods and will always throw an error if you try to chain any method off them. We call checking for null values &quot;Null Checking&quot;. In a simple case it would look something like this:</p>\n<pre><code class=\"language-js\">function stringify(param) {\n  if (param === null) return &quot;nullish&quot;;\n  return param.toString();\n}\n</code></pre>\n<p>And we can't just test falsiness like this <code>if(!param)</code> because an empty string, zero or <code>false</code> would be valid values in this case. And in Javascript we also must consider the <code>undefined</code> value that most other languages don't need to consider. So the implementation gets slightly longer:</p>\n<pre><code class=\"language-js\">function stringify(param) {\n  if (param === null || param === undefined) return &quot;nullish&quot;;\n  return param.toString();\n}\n</code></pre>\n<p>I am using the term &quot;Nullish Checking&quot; to refer to this kind of check for both <code>null</code> and <code>undefined</code> that is necessary in Javascript. The term borrows from the new nullish coalescing operator (<code>??</code>) added to the language in 2020.</p>\n<p>So that doesn't seem like a big deal to write and one could even create a <code>nullishCheck</code> function to encapsulate it for better resuse:</p>\n<pre><code class=\"language-js\">function isNullish(param) {\n  return param === null || param === undefined ? true : false;\n}\n\nfunction stringify(param) {\n  if (isNullish(param)) return &quot;nullish&quot;;\n  return param.toString();\n}\n</code></pre>\n<p>That would be totally fine, but I like to see if the language actually supports these kind of things natively as an exercise in trying to explore &quot;idiomatic javascript&quot;, which is the notion of using the language features as they are whenever possible, rather than bolting on your own utilities.</p>\n<h2>The valueOf trick</h2>\n<p>As a result of that exploration I stumbled on what I call the <code>valueOf</code> nullish check. You can use the native javascript method <code>valueOf</code> in a slightly clever way to check if a value is not <code>null</code> or <code>undefined</code>.</p>\n<pre><code class=\"language-js\">function stringify(param) {\n  if (!param?.valueOf) return &quot;nullish&quot;;\n  return param.toString();\n}\n</code></pre>\n<p>This leverages the optional chaining operator (which was also release to Javascript in 2020) and the native inherited Object method <code>valueOf</code>.</p>\n<p>It is checking to see if the <code>param</code> value has the method <code>valueOf</code> on its prototype. All values, except <code>null</code> and <code>undefined</code> will inherit the <code>valueOf</code> method from the <code>Object</code> prototype, so all possible values will return an uninvoked function body when evaluating <code>param?.valueOf</code>. Then we use a <code>!</code> to coerce it to a boolean and flip the boolean as needed to exit the funciton early if <code>param</code> doesn't inherit <code>valueOf</code> and is therefore either <code>null</code> or <code>undefined</code>.</p>\n<p>So our custom <code>isNullish(param)</code> utility and our native <code>!param?.valueOf</code> are almost equal number of characters (<code>isNullish</code> is one char longer, but the name could probably be shortened without losing legibility a bit), but <code>valueOf</code> leverages idiomatic Javascript by using a native method. And I would also go so far as to say it hits a semantically meaningful note to. The words &quot;value of&quot; do suggest it is checking for if there is something in that <code>param</code> rather than nothing, which is exaclty what a nullish check is intending to do. I think it's a pretty cool trick for the Javascript toolbox!</p>\n<h2>The null Object Pitfall</h2>\n<p>There is one catch though and it's one of those legitimate blemishes on Javascript as a language, in my opinion. It's <code>Object.create(null)</code>.</p>\n<p><code>Object.create(null)</code> creates a Javascript <code>Object</code> that has no methods on its prototype. It's like an Object that came out of some void with no context to it or relationship to Javascript's normal prototypal inheritance chain.</p>\n<p>So if we create an object this way it will not have the inherited method <code>valueOf</code> and it will appear to be nullish, even if we've added other methods to that object ourselves so it is an otherwise legitimate data structure.</p>\n<pre><code class=\"language-js\">const nullObj = Object.create(null);\nconst regularObj = Object.create({});\n\nconsole.log(nullObj); // {}\nconsole.log(nullObj.valueOf); // undefined\nconsole.log(regularObj.valueOf); // {}\nconsole.log(regularObj.valueOf); // Æ’ valueOf() { [native code] }\n</code></pre>\n<p>I believe using <code>Object.create</code> this way is an anti-pattern and should never be done. Indeed, you'll never encounter a null Object in Javascript unless your code or code you import invokes the <code>Object.create(null)</code> code that way. However I have encountered a few libraries on npm that initialize objects like this, I suppose to reduce their size, so it is out these even if you never write that line yourself.</p>\n<p>So you if you want to start using the <code>valueOf</code> trick for nullish checking you'll have to be on guard for libraries in your dependency chain that do this (and you'll have to make sure you don't do it either, of course, but that's easier to ensure). Luckily checking your dependencies for this pitfall isn't too difficult withmodern editors by just searching for the string <code>Object.create(null)</code> in your dependencies (node_modules) directory.</p>\n<p>And to all you library authors out there, please reconsider reaching for the <code>Object.create(null)</code> anti-pattern! It's not worth it to save a few bytes! Thanks :)</p>\n","ogImage":{"url":"/img/cover.jpg"},"coverImage":"/img/cover.jpg"}},"__N_SSG":true}