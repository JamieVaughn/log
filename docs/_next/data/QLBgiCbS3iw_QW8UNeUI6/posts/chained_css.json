{"pageProps":{"post":{"tags":["CSS","HTML"],"title":"Chained CSS Classes - A Proposal","date":"2019-12-29T12:35:07.322Z","slug":"chained_css","author":{"name":"Jamie Vaughn","picture":"/authors/jj.jpeg"},"content":"<h2>BEM - We've always done it this way.</h2>\n<p>For many developers, Block Element Modifier (BEM) is a beloved CSS naming convention for authoring CSS class names in a more systematic, extensible and maintainable way. It creates a taxonomy of CSS components based on a top-level <strong>block</strong> (i.e. the component wrapper) and any <strong>element</strong> within that component and finally any stylistic <strong>modifier</strong> that can be applied to one of those elements. The BEM style of authoring CSS classes looks like this:</p>\n<pre><code class=\"language-css\">.Block__Element--Modifier {\n  property: value;\n}\n</code></pre>\n<p>The choice of using a single class to semantically contain the entire block-element-modifier hierarchy is intentional. It reduces specificity of any given HTML element so that overwriting styles later on is less tedious. Unfortunately, this comes with the unwelcome side effect of being rather verbose.</p>\n<p>Now, if you only need the element or only the modifier you can reduce the verbosity like so:</p>\n<pre><code class=\"language-css\">/* Block component */\n.card {\n}\n/* Element that depends upon the block */\n.card__title {\n}\n/* Modifier that changes the style of the block */\n.card--large {\n}\n/* Modifier that changes the style of an element within the block */\n.card__title--large {\n}\n</code></pre>\n<p>But even so, this forces an incredible amount repitition within the HTML document. You must at minimum repeat the <strong>block</strong> name on nearly every child of the block... and you will likely be repeating the <strong>element</strong> names excessively, as well.</p>\n<pre><code class=\"language-html\">&lt;div class=&quot;block block__card--med&quot;&gt;...&lt;/div&gt;\n&lt;div class=&quot;block__card--large block__card--dropshadow&quot;&gt;...&lt;/div&gt;\n</code></pre>\n<p>Gross ðŸ¤¢ !</p>\n<p>And if you need to add multiple modifiers, I'm not certain what the preferred syntax is between long chains of <code>block__element--modifier1--modifier2</code> or repeating the entire thing: <code>block__element--modifier1 block__element--modifier2</code>. You can always make sure you author your <strong>modifier</strong> so that every style is comprehensive to avoid such a repetitious situation, but then you will find yourself repeating chunks of style properties elsewhere in other modifiers which share portions of styles but not 100% of those styles. CSS pre-processors can come to the rescue here to a degree by taking advantage of <code>mixins</code> and <code>extends</code> syntax. But it's only a band-aid... there's a verbosity problem that is at the root of this organizational rubric.</p>\n<p>Is there a way to get the hierarchical organization without such verbosity? Maybe by just using simple CSS classes as they were originally intended?</p>\n<h2>What about a systematic method of chaining CSS classes?</h2>\n<p>Let's try to take the Block, Element, Modifier system from BEM but reimagined it with simpler CSS class naming conventions. What might that look like?</p>\n<pre><code class=\"language-css\">/* Block component */\n.card {\n}\n/* Element that depends upon the block */\n.card .title {\n}\n/* Modifier that changes the style of the block */\n.card.large {\n}\n/* Modifier that changes the style of an element within the block */\n.card .title.large {\n}\n</code></pre>\n<p>Here now we significantly reduce the amount of extra text in our HTML markup because there is no need to repeat the <code>card</code> class or the <code>title</code> class more than a single time per component. And with CSS pre-processors the CSS actually improves more than our BEM counterpart because we do not even need to repeat the <code>card</code> class more than once for the component with the help of nesting:</p>\n<pre><code class=\"language-css\">.card {\n  &amp;.large {\n  }\n  .title {\n    &amp;.large {\n    }\n  }\n}\n</code></pre>\n<p>Now, we do increase the specificity of our selectors somewhat but not drastically. We start creeping up to a specificity of around 30 (or a perhaps bit more if several modifiers are tacked on), instead of only 10. I don't see that as a deal breaker, myself. And if that is something that is especially concerning, then we can take advantage of the new <code>:where()</code> selector in CSS, because that affords us a nesting like syntax and omits any specifity contribution from selectors within it. With <code>:where()</code> we can tack on as many modifiers as we want without increasing the css. For example:</p>\n<pre><code class=\"language-css\">/* These have specificity of 10 */\n:where(.block) .element:where(.modifier, .large, .dropshadow, .primary) {\n}\n:where(.block) .element :where(.modifier, .large, .dropshadow, .primary) {\n}\n</code></pre>\n<p>And we get all of that without even the need of more complicated mixins! Our modifier classes become our mixins and we define a set of &quot;global&quot; baseline modifiers with basic styles that all instances of the modifier would use. And then simply add the unique styles to the nested instances of the modifiers as required by the block and element they appear in. Let's see an example of that:</p>\n<pre><code class=\"language-css\">.large {\n  font-size: 2em;\n}\n.card {\n  .title {\n    &amp;.large {\n      font-weight: bold;\n    }\n  }\n}\n.nav {\n  .link {\n    &amp;.large {\n      letter-spacing: 2px;\n    }\n  }\n}\n</code></pre>\n<h2>Where have I heard &quot;Element&quot; before?</h2>\n<p>I don't know about you, but that looks nicer to me! But wait could we further reduce the verbosity by rethinking the <strong>element</strong> from the BEM convention? Why don't we just use the HTML Element tag names as the <strong>element</strong> naming convention? There's a certian semantic resonance in that, isn't there? so Our example above would be shortened to:</p>\n<pre><code class=\"language-css\">.large {\n  font-size: 2em;\n}\n.card {\n  h2 {\n    &amp;.large {\n      font-weight: bold;\n    }\n  }\n}\n.nav {\n  a {\n    &amp;.large {\n      letter-spacing: 2px;\n    }\n  }\n}\n</code></pre>\n<p>This might not look like much of a change, but it does two things. First, we reduce our specificity back down to almost where the minimum BEM convention would have it. Second, we further reduce our HTML clutter by removing the need for more classes on <strong>element</strong> level HTML tags. And as long as the tags are children of the <strong>block</strong> there will be no style collisions! ðŸ™Œ</p>\n<p>One last piece of organization that is possible (but entirely optional) is separating out each of the levels of css into its own file:</p>\n<table>\n    <thead>\n        <tr>\n            <th>Block</th>\n            <th>Element</th>\n            <th>Modifier</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td><code>.Header</code></td>\n            <td><code>.title</code></td>\n            <td><code>.bold</code></td>\n        </tr>\n        <tr>\n            <td>blocks.css</td>\n            <td>elements.css</td>\n            <td>modifiers.css</td>\n        </tr>\n    </tbody>\n</table>\n<p>And then one more file called <code>chains.css</code> could be added for including chained css that has three levels of chaining (<code>.Header.title.bold</code>)when its necessary to do so to overwrite other css rules or customize things further.</p>\n","ogImage":{"url":"/img/cover.jpg"},"coverImage":"/img/cover.jpg"}},"__N_SSG":true}