{"pageProps":{"post":{"title":"The Null Object Pattern in the Functional Style","date":"2020-02-20T08:50:07.322Z","slug":"null_object_fp","author":{"name":"Jamie Vaughn","picture":"/authors/jj.jpeg"},"content":"<p>The Null Object Pattern is a common way in OOP to handle <code>null</code> references in a graceful way. If a reference to an object is <code>null</code> and a method is invoked on that reference, then this will cause an error. Instead, a Null Object can be implemented with the same interface, but where the methods are no-op methods. Other objects can inherit from this Null Object in such a way, that if a <code>null</code> reference is passed then they will use the no-op methods from the Null Object rather than throwing an error.</p>\n<p>Why not just use conditional checks using <code>if</code> statements to check for null? You certainly can. But in OOP it is prefered to use polymorphism over conditionals where possible. In FP, there isn't really an exact counterpart to polymorphism so replicating it takes some adaptation. But in both paradigms, the avoidance of conditionals and <code>if</code> statements is desired and can be achieved because the goal is to reduce branching in the program. The problem with handling <code>null</code> is that it necessarily adds branching to your logic, because you now have to handle another case. But the Null Object Pattern, while not completely removing it, can at least encapsulate and hide that branching for us.</p>\n<h2>Typical OOP implementation in JS</h2>\n<pre><code class=\"language-js\">class Discount {\n  calculateDiscount() {\n    return 0.15;\n  }\n}\nclass NoDiscount {\n  calculateDiscount() {\n    return null;\n  }\n}\nfunction getDiscount(orderType) {\n  return orderType === &quot;matinÃ©e&quot; ? new Discount() : new NoDiscount();\n}\n\n[getDiscount(&quot;matinÃ©e&quot;), null].map((o) =&gt; getDiscount(o).calculateDiscount()); // [0.15, null]\n</code></pre>\n<p>Using the null object pattern, a special version of the Class is created that has the same method and signature, but it only handles <code>null</code> values and mitigates the need for more tedious control flow logic that checks for <code>null</code> values in the original class interface.</p>\n<h2>Typical Functional implementation in JS</h2>\n<p>Previously we saw a way to implement the Null Object Pattern in an OOP style. A functional style of handling it would look like this:</p>\n<pre><code class=\"language-js\">function Discounts(type) {\n  let types = {\n    regular: {\n      calc() {\n        return 0.15;\n      },\n    },\n    nullDiscount: {\n      calc() {\n        return null;\n      },\n    },\n  };\n  return types[type] || types.nullDiscount;\n}\nDiscounts(&quot;regular&quot;).calc(); // 0.15\nDiscounts(null).calc(); // null\n</code></pre>\n<h2>ECMAScript 2020: Is this pattern necessary anymore?</h2>\n<p>In the latest version of ECMAScript there are a couple of operators that more or less obviate the need to implement a custom Null Object handler. They are called Optional Chaining (<code>?.</code>) and Nullish Coalescing (<code>??</code>).</p>\n<p>Optional Chaining can be used when trying to access methods or properties on any object such that accessing an undefined property will not cause an error and instead it can be handled with minimal control flow. It would look like this:</p>\n<pre><code class=\"language-js\">class Discount {\n  calc() {\n    return 0.15;\n  }\n  days = &quot;MTWTF&quot;;\n}\nlet special = new Discount();\nspecial.calc?.(); // 0.15\nspecial.order(); // Uncaught TypeError ðŸ¤¬\nspecial.order?.(); // undefined (ok, that's better)\nspecial.order?.() || &quot;No specials&quot;; // 'No specials' (NICE!)\nspecial.day; // undefined anyways so optional chaining is not needed for properties\n</code></pre>\n<p>When we call the non-existent <code>order</code> method unsafely we get an uncaught type error ðŸ¤¬. We want to avoidthat at all costs. Optional chaining allows us to call <code>order</code> in a safe way which can be handled by error paths in the code relatively easily.</p>\n<p>This works the same for JS objects:</p>\n<pre><code class=\"language-js\">let obj = {\n  days: 'MWT',\n  order: () =&gt; ['burger', 'fries']\n  points: () =&gt; 0\n}\n\nobj.day // undefined already (it's a property, not a method)\nobj.special() // Uncaught TypeError ðŸ¤¬\nobj.special?.() // undefined\n</code></pre>\n<p>And we can combine this with Nullish Coallescing to get a fully operational Null Object Handling that also respects intentional falsey values. It's a one liner that can fit anywhere in our code when referencing potentially non-existent methods:</p>\n<pre><code class=\"language-js\">// using `obj` from previous code block\nobj.special?.() ?? &quot;No Special&quot;; // 'No Special'\nobj.points?.() || &quot;Could not fetch points&quot;; // 'Could not fetch points'\nobj.points?.() ?? &quot;Could not fetch points&quot;; // 0\n</code></pre>\n<p>So we can see the Nullish Coalescer allows us to handle null and undefined methods alongside methods that may return falsy values like <code>0</code> or <code>''</code> or <code>false</code>.</p>\n<p>So is optional chaining combined with nullish coalescing enough to recreate the Null Object pattern in JS? I think so, but perhaps others may still build something more robust like Maybe Monads or Null Object Handling Classes. But I'll be reaching for hese two new tools, optional chaing and nullish coallescing, in ECMAScript first in my programs before opting to go with the more complex patterns.</p>\n","ogImage":{"url":"/img/cover.jpg"},"coverImage":"/img/cover.jpg"}},"__N_SSG":true}